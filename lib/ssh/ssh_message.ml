(* This file was autogenerated by MPL *)
module Transport = struct
  open Mpl_stdlib
  exception Bad_packet of string

  type statecalls = [
    |`Transmit_Transport_Unimplemented |`Receive_Transport_Unimplemented
    |`Transmit_Transport_ServiceAccept_UserAuth |`Receive_Transport_ServiceAccept_UserAuth
    |`Transmit_Transport_Ignore |`Receive_Transport_Ignore
    |`Transmit_Transport_ServiceReq_UserAuth |`Receive_Transport_ServiceReq_UserAuth
    |`Transmit_Transport_ServiceAccept_Connection |`Receive_Transport_ServiceAccept_Connection
    |`Transmit_Transport_ServiceReq_Connection |`Receive_Transport_ServiceReq_Connection
    |`Transmit_Transport_Debug |`Receive_Transport_Debug
    |`Transmit_Transport_Disconnect |`Receive_Transport_Disconnect
    |`Transmit_Transport_KexInit |`Receive_Transport_KexInit
    |`Transmit_Transport_NewKeys |`Receive_Transport_NewKeys
  ]

  module NewKeys = struct
    class o
      (env:env) =
      object(self)
        method env = env_at env 0 self#sizeof
        method sizeof = 1
        method xmit_statecall : [ `Transmit_Transport_NewKeys] = `Transmit_Transport_NewKeys
        method packet_start = 0


        method packet_end = 1


        method prettyprint =
          let out = prerr_endline in
          out "[ Transport.NewKeys.transport ]";
          (* packet_start : bound *)
          (* ptype : bound *)
          (* packet_end : bound *)
          ()
      end

    let t
      env =
        let ptype = (Mpl_byte.of_int 21) in (* const *)
        Mpl_byte.marshal env ptype;
        new o
        env

    let m (x:(env->o)) env = x env
    let sizeof (x:o) = x#sizeof
    let prettyprint (x:o) = x#prettyprint
    let env (x:o) = x#env
    let recv_statecall = `Receive_Transport_NewKeys
  end

  module KexInit = struct
    class o
      ~kex_algorithms
      ~server_host_key_algorithms
      ~encryption_algorithms_client_to_server
      ~encryption_algorithms_server_to_client
      ~mac_algorithms_client_to_server
      ~mac_algorithms_server_to_client
      ~compression_algorithms_client_to_server
      ~compression_algorithms_server_to_client
      ~languages_client_to_server
      ~languages_server_to_client
      ~kex_packet_follows
      (env:env) =
      object(self)
        method env = env_at env 0 self#sizeof
        method sizeof = 4+1+(Mpl_string32.size languages_server_to_client)+(Mpl_string32.size languages_client_to_server)+(Mpl_string32.size compression_algorithms_server_to_client)+(Mpl_string32.size compression_algorithms_client_to_server)+(Mpl_string32.size mac_algorithms_server_to_client)+(Mpl_string32.size mac_algorithms_client_to_server)+(Mpl_string32.size encryption_algorithms_server_to_client)+(Mpl_string32.size encryption_algorithms_client_to_server)+(Mpl_string32.size server_host_key_algorithms)+(Mpl_string32.size kex_algorithms)+16+1
        method xmit_statecall : [ `Transmit_Transport_KexInit] = `Transmit_Transport_KexInit
        method packet_start = 0


        method cookie =
          Mpl_raw.at env (1) 16
        (* set_cookie unsupported for now (type byte array) *)
        method cookie_env : env = env_at env (1) 16
        method cookie_frag = Mpl_raw.frag env (1) 16
        method cookie_length = 16

        method kex_algorithms =
          (Mpl_string32.to_string kex_algorithms)
        (* set_kex_algorithms unsupported for now (type custom_type) *)

        method server_host_key_algorithms =
          (Mpl_string32.to_string server_host_key_algorithms)
        (* set_server_host_key_algorithms unsupported for now (type custom_type) *)

        method encryption_algorithms_client_to_server =
          (Mpl_string32.to_string encryption_algorithms_client_to_server)
        (* set_encryption_algorithms_client_to_server unsupported for now (type custom_type) *)

        method encryption_algorithms_server_to_client =
          (Mpl_string32.to_string encryption_algorithms_server_to_client)
        (* set_encryption_algorithms_server_to_client unsupported for now (type custom_type) *)

        method mac_algorithms_client_to_server =
          (Mpl_string32.to_string mac_algorithms_client_to_server)
        (* set_mac_algorithms_client_to_server unsupported for now (type custom_type) *)

        method mac_algorithms_server_to_client =
          (Mpl_string32.to_string mac_algorithms_server_to_client)
        (* set_mac_algorithms_server_to_client unsupported for now (type custom_type) *)

        method compression_algorithms_client_to_server =
          (Mpl_string32.to_string compression_algorithms_client_to_server)
        (* set_compression_algorithms_client_to_server unsupported for now (type custom_type) *)

        method compression_algorithms_server_to_client =
          (Mpl_string32.to_string compression_algorithms_server_to_client)
        (* set_compression_algorithms_server_to_client unsupported for now (type custom_type) *)

        method languages_client_to_server =
          (Mpl_string32.to_string languages_client_to_server)
        (* set_languages_client_to_server unsupported for now (type custom_type) *)

        method languages_server_to_client =
          (Mpl_string32.to_string languages_server_to_client)
        (* set_languages_server_to_client unsupported for now (type custom_type) *)

        method kex_packet_follows =
          (Mpl_boolean.to_bool kex_packet_follows)
        (* set_kex_packet_follows unsupported for now (type custom_type) *)


        method packet_end = 1+16+(Mpl_string32.size kex_algorithms)+(Mpl_string32.size server_host_key_algorithms)+(Mpl_string32.size encryption_algorithms_client_to_server)+(Mpl_string32.size encryption_algorithms_server_to_client)+(Mpl_string32.size mac_algorithms_client_to_server)+(Mpl_string32.size mac_algorithms_server_to_client)+(Mpl_string32.size compression_algorithms_client_to_server)+(Mpl_string32.size compression_algorithms_server_to_client)+(Mpl_string32.size languages_client_to_server)+(Mpl_string32.size languages_server_to_client)+1+4


        method prettyprint =
          let out = prerr_endline in
          out "[ Transport.KexInit.transport ]";
          (* packet_start : bound *)
          (* ptype : bound *)
          out ("  cookie = " ^ (Mpl_raw.prettyprint self#cookie));
          out ("  kex_algorithms = " ^ (Mpl_string32.prettyprint self#kex_algorithms));
          out ("  server_host_key_algorithms = " ^ (Mpl_string32.prettyprint self#server_host_key_algorithms));
          out ("  encryption_algorithms_client_to_server = " ^ (Mpl_string32.prettyprint self#encryption_algorithms_client_to_server));
          out ("  encryption_algorithms_server_to_client = " ^ (Mpl_string32.prettyprint self#encryption_algorithms_server_to_client));
          out ("  mac_algorithms_client_to_server = " ^ (Mpl_string32.prettyprint self#mac_algorithms_client_to_server));
          out ("  mac_algorithms_server_to_client = " ^ (Mpl_string32.prettyprint self#mac_algorithms_server_to_client));
          out ("  compression_algorithms_client_to_server = " ^ (Mpl_string32.prettyprint self#compression_algorithms_client_to_server));
          out ("  compression_algorithms_server_to_client = " ^ (Mpl_string32.prettyprint self#compression_algorithms_server_to_client));
          out ("  languages_client_to_server = " ^ (Mpl_string32.prettyprint self#languages_client_to_server));
          out ("  languages_server_to_client = " ^ (Mpl_string32.prettyprint self#languages_server_to_client));
          out ("  kex_packet_follows = " ^ (Mpl_boolean.prettyprint self#kex_packet_follows));
          (* reserved : bound *)
          (* packet_end : bound *)
          ()
      end

    let t
      ~(cookie:data)
      ~kex_algorithms
      ~server_host_key_algorithms
      ~encryption_algorithms_client_to_server
      ~encryption_algorithms_server_to_client
      ~mac_algorithms_client_to_server
      ~mac_algorithms_server_to_client
      ~compression_algorithms_client_to_server
      ~compression_algorithms_server_to_client
      ~languages_client_to_server
      ~languages_server_to_client
      ~kex_packet_follows
      env =
        let kex_algorithms = (Mpl_string32.of_string kex_algorithms) in (* custom *)
        let server_host_key_algorithms = (Mpl_string32.of_string server_host_key_algorithms) in (* custom *)
        let encryption_algorithms_client_to_server = (Mpl_string32.of_string encryption_algorithms_client_to_server) in (* custom *)
        let encryption_algorithms_server_to_client = (Mpl_string32.of_string encryption_algorithms_server_to_client) in (* custom *)
        let mac_algorithms_client_to_server = (Mpl_string32.of_string mac_algorithms_client_to_server) in (* custom *)
        let mac_algorithms_server_to_client = (Mpl_string32.of_string mac_algorithms_server_to_client) in (* custom *)
        let compression_algorithms_client_to_server = (Mpl_string32.of_string compression_algorithms_client_to_server) in (* custom *)
        let compression_algorithms_server_to_client = (Mpl_string32.of_string compression_algorithms_server_to_client) in (* custom *)
        let languages_client_to_server = (Mpl_string32.of_string languages_client_to_server) in (* custom *)
        let languages_server_to_client = (Mpl_string32.of_string languages_server_to_client) in (* custom *)
        let kex_packet_follows = (Mpl_boolean.of_bool kex_packet_follows) in (* custom *)
        let ___env = env_at env (1) 0 in
        let cookie___len = match cookie with 
        |`Str x -> Mpl_raw.marshal ___env x; String.length x
        |`Sub fn -> fn ___env; curpos ___env
        |`None -> 0
        |`Frag t -> Mpl_raw.blit ___env t; curpos ___env in
        let ptype = (Mpl_byte.of_int 20) in (* const *)
        let reserved = (Mpl_uint32.of_int32 0l) in (* const *)
        let cookie = cookie in
        Mpl_byte.marshal env ptype;
        skip env cookie___len;
        let kex_algorithms = Mpl_string32.marshal env kex_algorithms in
        let server_host_key_algorithms = Mpl_string32.marshal env server_host_key_algorithms in
        let encryption_algorithms_client_to_server = Mpl_string32.marshal env encryption_algorithms_client_to_server in
        let encryption_algorithms_server_to_client = Mpl_string32.marshal env encryption_algorithms_server_to_client in
        let mac_algorithms_client_to_server = Mpl_string32.marshal env mac_algorithms_client_to_server in
        let mac_algorithms_server_to_client = Mpl_string32.marshal env mac_algorithms_server_to_client in
        let compression_algorithms_client_to_server = Mpl_string32.marshal env compression_algorithms_client_to_server in
        let compression_algorithms_server_to_client = Mpl_string32.marshal env compression_algorithms_server_to_client in
        let languages_client_to_server = Mpl_string32.marshal env languages_client_to_server in
        let languages_server_to_client = Mpl_string32.marshal env languages_server_to_client in
        let kex_packet_follows = Mpl_boolean.marshal env kex_packet_follows in
        Mpl_uint32.marshal env reserved;
        new o
        ~kex_algorithms:kex_algorithms
        ~server_host_key_algorithms:server_host_key_algorithms
        ~encryption_algorithms_client_to_server:encryption_algorithms_client_to_server
        ~encryption_algorithms_server_to_client:encryption_algorithms_server_to_client
        ~mac_algorithms_client_to_server:mac_algorithms_client_to_server
        ~mac_algorithms_server_to_client:mac_algorithms_server_to_client
        ~compression_algorithms_client_to_server:compression_algorithms_client_to_server
        ~compression_algorithms_server_to_client:compression_algorithms_server_to_client
        ~languages_client_to_server:languages_client_to_server
        ~languages_server_to_client:languages_server_to_client
        ~kex_packet_follows:kex_packet_follows
        env

    let m (x:(env->o)) env = x env
    let sizeof (x:o) = x#sizeof
    let prettyprint (x:o) = x#prettyprint
    let env (x:o) = x#env
    let recv_statecall = `Receive_Transport_KexInit
  end

  module ServiceAccept = struct
    module Connection = struct
      class o
        ~stype
        (env:env) =
        object(self)
          method env = env_at env 0 self#sizeof
          method sizeof = (Mpl_string32.size stype)+1
          method xmit_statecall : [ `Transmit_Transport_ServiceAccept_Connection] = `Transmit_Transport_ServiceAccept_Connection
          method packet_start = 0



          method packet_end = 1+(Mpl_string32.size stype)


          method prettyprint =
            let out = prerr_endline in
            out "[ Transport.ServiceAccept.Connection.transport ]";
            (* packet_start : bound *)
            (* ptype : bound *)
            (* stype : bound *)
            (* packet_end : bound *)
            ()
        end

      let t
        env =
          let ptype = (Mpl_byte.of_int 6) in (* const *)
          let stype = (Mpl_string32.of_string "ssh-connection") in (* const *)
          Mpl_byte.marshal env ptype;
          let stype = Mpl_string32.marshal env stype in
          new o
          ~stype:stype
          env

      let m (x:(env->o)) env = x env
      let sizeof (x:o) = x#sizeof
      let prettyprint (x:o) = x#prettyprint
      let env (x:o) = x#env
      let recv_statecall = `Receive_Transport_ServiceAccept_Connection
    end

    module UserAuth = struct
      class o
        ~stype
        (env:env) =
        object(self)
          method env = env_at env 0 self#sizeof
          method sizeof = (Mpl_string32.size stype)+1
          method xmit_statecall : [ `Transmit_Transport_ServiceAccept_UserAuth] = `Transmit_Transport_ServiceAccept_UserAuth
          method packet_start = 0



          method packet_end = 1+(Mpl_string32.size stype)


          method prettyprint =
            let out = prerr_endline in
            out "[ Transport.ServiceAccept.UserAuth.transport ]";
            (* packet_start : bound *)
            (* ptype : bound *)
            (* stype : bound *)
            (* packet_end : bound *)
            ()
        end

      let t
        env =
          let ptype = (Mpl_byte.of_int 6) in (* const *)
          let stype = (Mpl_string32.of_string "ssh-userauth") in (* const *)
          Mpl_byte.marshal env ptype;
          let stype = Mpl_string32.marshal env stype in
          new o
          ~stype:stype
          env

      let m (x:(env->o)) env = x env
      let sizeof (x:o) = x#sizeof
      let prettyprint (x:o) = x#prettyprint
      let env (x:o) = x#env
      let recv_statecall = `Receive_Transport_ServiceAccept_UserAuth
    end

    type o = [
    |`UserAuth of UserAuth.o
    |`Connection of Connection.o
    ]

    type x = [
    |`UserAuth of (env -> UserAuth.o)
    |`Connection of (env -> Connection.o)
    ]

    let m (x:x) env : o = match x with
    |`UserAuth (fn:(env->UserAuth.o)) -> `UserAuth (fn env)
    |`Connection (fn:(env->Connection.o)) -> `Connection (fn env)

    let prettyprint (x:o) = match x with
    |`UserAuth x -> x#prettyprint
    |`Connection x -> x#prettyprint

    let sizeof (x:o) = match x with
    |`UserAuth x -> x#sizeof
    |`Connection x -> x#sizeof

    let env (x:o) = match x with
    |`UserAuth x -> x#env
    |`Connection x -> x#env

    let recv_statecall (x:o) = match x with
    |`UserAuth x -> UserAuth.recv_statecall 
    |`Connection x -> Connection.recv_statecall 

  end

  module ServiceReq = struct
    module Connection = struct
      class o
        ~stype
        (env:env) =
        object(self)
          method env = env_at env 0 self#sizeof
          method sizeof = (Mpl_string32.size stype)+1
          method xmit_statecall : [ `Transmit_Transport_ServiceReq_Connection] = `Transmit_Transport_ServiceReq_Connection
          method packet_start = 0



          method packet_end = 1+(Mpl_string32.size stype)


          method prettyprint =
            let out = prerr_endline in
            out "[ Transport.ServiceReq.Connection.transport ]";
            (* packet_start : bound *)
            (* ptype : bound *)
            (* stype : bound *)
            (* packet_end : bound *)
            ()
        end

      let t
        env =
          let ptype = (Mpl_byte.of_int 5) in (* const *)
          let stype = (Mpl_string32.of_string "ssh-connection") in (* const *)
          Mpl_byte.marshal env ptype;
          let stype = Mpl_string32.marshal env stype in
          new o
          ~stype:stype
          env

      let m (x:(env->o)) env = x env
      let sizeof (x:o) = x#sizeof
      let prettyprint (x:o) = x#prettyprint
      let env (x:o) = x#env
      let recv_statecall = `Receive_Transport_ServiceReq_Connection
    end

    module UserAuth = struct
      class o
        ~stype
        (env:env) =
        object(self)
          method env = env_at env 0 self#sizeof
          method sizeof = (Mpl_string32.size stype)+1
          method xmit_statecall : [ `Transmit_Transport_ServiceReq_UserAuth] = `Transmit_Transport_ServiceReq_UserAuth
          method packet_start = 0



          method packet_end = 1+(Mpl_string32.size stype)


          method prettyprint =
            let out = prerr_endline in
            out "[ Transport.ServiceReq.UserAuth.transport ]";
            (* packet_start : bound *)
            (* ptype : bound *)
            (* stype : bound *)
            (* packet_end : bound *)
            ()
        end

      let t
        env =
          let ptype = (Mpl_byte.of_int 5) in (* const *)
          let stype = (Mpl_string32.of_string "ssh-userauth") in (* const *)
          Mpl_byte.marshal env ptype;
          let stype = Mpl_string32.marshal env stype in
          new o
          ~stype:stype
          env

      let m (x:(env->o)) env = x env
      let sizeof (x:o) = x#sizeof
      let prettyprint (x:o) = x#prettyprint
      let env (x:o) = x#env
      let recv_statecall = `Receive_Transport_ServiceReq_UserAuth
    end

    type o = [
    |`UserAuth of UserAuth.o
    |`Connection of Connection.o
    ]

    type x = [
    |`UserAuth of (env -> UserAuth.o)
    |`Connection of (env -> Connection.o)
    ]

    let m (x:x) env : o = match x with
    |`UserAuth (fn:(env->UserAuth.o)) -> `UserAuth (fn env)
    |`Connection (fn:(env->Connection.o)) -> `Connection (fn env)

    let prettyprint (x:o) = match x with
    |`UserAuth x -> x#prettyprint
    |`Connection x -> x#prettyprint

    let sizeof (x:o) = match x with
    |`UserAuth x -> x#sizeof
    |`Connection x -> x#sizeof

    let env (x:o) = match x with
    |`UserAuth x -> x#env
    |`Connection x -> x#env

    let recv_statecall (x:o) = match x with
    |`UserAuth x -> UserAuth.recv_statecall 
    |`Connection x -> Connection.recv_statecall 

  end

  module Debug = struct
    class o
      ~always_display
      ~message
      ~language
      (env:env) =
      object(self)
        method env = env_at env 0 self#sizeof
        method sizeof = (Mpl_string32.size language)+(Mpl_string32.size message)+1+1
        method xmit_statecall : [ `Transmit_Transport_Debug] = `Transmit_Transport_Debug
        method packet_start = 0


        method always_display =
          (Mpl_boolean.to_bool always_display)
        (* set_always_display unsupported for now (type custom_type) *)

        method message =
          (Mpl_string32.to_string message)
        (* set_message unsupported for now (type custom_type) *)

        method language =
          (Mpl_string32.to_string language)
        (* set_language unsupported for now (type custom_type) *)

        method packet_end = 1+1+(Mpl_string32.size message)+(Mpl_string32.size language)


        method prettyprint =
          let out = prerr_endline in
          out "[ Transport.Debug.transport ]";
          (* packet_start : bound *)
          (* ptype : bound *)
          out ("  always_display = " ^ (Mpl_boolean.prettyprint self#always_display));
          out ("  message = " ^ (Mpl_string32.prettyprint self#message));
          out ("  language = " ^ (Mpl_string32.prettyprint self#language));
          (* packet_end : bound *)
          ()
      end

    let t
      ~always_display
      ~message
      ~language
      env =
        let always_display = (Mpl_boolean.of_bool always_display) in (* custom *)
        let message = (Mpl_string32.of_string message) in (* custom *)
        let language = (Mpl_string32.of_string language) in (* custom *)
        let ptype = (Mpl_byte.of_int 4) in (* const *)
        Mpl_byte.marshal env ptype;
        let always_display = Mpl_boolean.marshal env always_display in
        let message = Mpl_string32.marshal env message in
        let language = Mpl_string32.marshal env language in
        new o
        ~always_display:always_display
        ~message:message
        ~language:language
        env

    let m (x:(env->o)) env = x env
    let sizeof (x:o) = x#sizeof
    let prettyprint (x:o) = x#prettyprint
    let env (x:o) = x#env
    let recv_statecall = `Receive_Transport_Debug
  end

  module Unimplemented = struct
    class o
      (env:env) =
      object(self)
        method env = env_at env 0 self#sizeof
        method sizeof = 4+1
        method xmit_statecall : [ `Transmit_Transport_Unimplemented] = `Transmit_Transport_Unimplemented
        method packet_start = 0


        method seq_num =
          Mpl_uint32.to_int32 (Mpl_uint32.at env (1))
        method set_seq_num v : unit =
          Mpl_uint32.marshal (env_at env (1) 4) (Mpl_uint32.of_int32 v)

        method packet_end = 1+4


        method prettyprint =
          let out = prerr_endline in
          out "[ Transport.Unimplemented.transport ]";
          (* packet_start : bound *)
          (* ptype : bound *)
          out ("  seq_num = " ^ (Printf.sprintf "%lu" self#seq_num));
          (* packet_end : bound *)
          ()
      end

    let t
      ~seq_num
      env =
        let ptype = (Mpl_byte.of_int 3) in (* const *)
        let seq_num = (Mpl_uint32.of_int32 seq_num) in
        Mpl_byte.marshal env ptype;
        Mpl_uint32.marshal env seq_num;
        new o
        env

    let m (x:(env->o)) env = x env
    let sizeof (x:o) = x#sizeof
    let prettyprint (x:o) = x#prettyprint
    let env (x:o) = x#env
    let recv_statecall = `Receive_Transport_Unimplemented
  end

  module Ignore = struct
    class o
      ~data
      (env:env) =
      object(self)
        method env = env_at env 0 self#sizeof
        method sizeof = (Mpl_string32.size data)+1
        method xmit_statecall : [ `Transmit_Transport_Ignore] = `Transmit_Transport_Ignore
        method packet_start = 0


        method data =
          (Mpl_string32.to_string data)
        (* set_data unsupported for now (type custom_type) *)

        method packet_end = 1+(Mpl_string32.size data)


        method prettyprint =
          let out = prerr_endline in
          out "[ Transport.Ignore.transport ]";
          (* packet_start : bound *)
          (* ptype : bound *)
          out ("  data = " ^ (Mpl_string32.prettyprint self#data));
          (* packet_end : bound *)
          ()
      end

    let t
      ~data
      env =
        let data = (Mpl_string32.of_string data) in (* custom *)
        let ptype = (Mpl_byte.of_int 2) in (* const *)
        Mpl_byte.marshal env ptype;
        let data = Mpl_string32.marshal env data in
        new o
        ~data:data
        env

    let m (x:(env->o)) env = x env
    let sizeof (x:o) = x#sizeof
    let prettyprint (x:o) = x#prettyprint
    let env (x:o) = x#env
    let recv_statecall = `Receive_Transport_Ignore
  end

  module Disconnect = struct
    type reason_code_t = [
      |`Host_not_allowed
      |`Protocol_error
      |`Kex_failed
      |`Reserved
      |`MAC_error
      |`Compression_error
      |`Service_not_available
      |`Protocol_version_not_supported
      |`Host_key_not_verifiable
      |`Connection_lost
      |`By_application
      |`Too_many_connections
      |`Auth_cancelled_by_user
      |`No_more_auth_methods_available
      |`Illegal_user_name
      |`Unknown of int32
    ]

    let reason_code_marshal (a:reason_code_t) =
      match a with
      |`Host_not_allowed -> 1l
      |`Protocol_error -> 2l
      |`Kex_failed -> 3l
      |`Reserved -> 4l
      |`MAC_error -> 5l
      |`Compression_error -> 6l
      |`Service_not_available -> 7l
      |`Protocol_version_not_supported -> 8l
      |`Host_key_not_verifiable -> 9l
      |`Connection_lost -> 10l
      |`By_application -> 11l
      |`Too_many_connections -> 12l
      |`Auth_cancelled_by_user -> 13l
      |`No_more_auth_methods_available -> 14l
      |`Illegal_user_name -> 15l
      |`Unknown x -> x

    let reason_code_unmarshal a : reason_code_t =
      match a with
      |1l -> `Host_not_allowed
      |2l -> `Protocol_error
      |3l -> `Kex_failed
      |4l -> `Reserved
      |5l -> `MAC_error
      |6l -> `Compression_error
      |7l -> `Service_not_available
      |8l -> `Protocol_version_not_supported
      |9l -> `Host_key_not_verifiable
      |10l -> `Connection_lost
      |11l -> `By_application
      |12l -> `Too_many_connections
      |13l -> `Auth_cancelled_by_user
      |14l -> `No_more_auth_methods_available
      |15l -> `Illegal_user_name
      |x -> `Unknown x

    let reason_code_to_string (a:reason_code_t) =
      match a with
      |`Host_not_allowed -> "Host_not_allowed"
      |`Protocol_error -> "Protocol_error"
      |`Kex_failed -> "Kex_failed"
      |`Reserved -> "Reserved"
      |`MAC_error -> "MAC_error"
      |`Compression_error -> "Compression_error"
      |`Service_not_available -> "Service_not_available"
      |`Protocol_version_not_supported -> "Protocol_version_not_supported"
      |`Host_key_not_verifiable -> "Host_key_not_verifiable"
      |`Connection_lost -> "Connection_lost"
      |`By_application -> "By_application"
      |`Too_many_connections -> "Too_many_connections"
      |`Auth_cancelled_by_user -> "Auth_cancelled_by_user"
      |`No_more_auth_methods_available -> "No_more_auth_methods_available"
      |`Illegal_user_name -> "Illegal_user_name"
      |`Unknown x -> Printf.sprintf "%ld" x

    let reason_code_of_string s : reason_code_t option = match s with
      |"Host_not_allowed" -> Some `Host_not_allowed
      |"Protocol_error" -> Some `Protocol_error
      |"Kex_failed" -> Some `Kex_failed
      |"Reserved" -> Some `Reserved
      |"MAC_error" -> Some `MAC_error
      |"Compression_error" -> Some `Compression_error
      |"Service_not_available" -> Some `Service_not_available
      |"Protocol_version_not_supported" -> Some `Protocol_version_not_supported
      |"Host_key_not_verifiable" -> Some `Host_key_not_verifiable
      |"Connection_lost" -> Some `Connection_lost
      |"By_application" -> Some `By_application
      |"Too_many_connections" -> Some `Too_many_connections
      |"Auth_cancelled_by_user" -> Some `Auth_cancelled_by_user
      |"No_more_auth_methods_available" -> Some `No_more_auth_methods_available
      |"Illegal_user_name" -> Some `Illegal_user_name
      |_ -> None

    class o
      ~description
      ~language
      (env:env) =
      object(self)
        method env = env_at env 0 self#sizeof
        method sizeof = (Mpl_string32.size language)+(Mpl_string32.size description)+4+1
        method xmit_statecall : [ `Transmit_Transport_Disconnect] = `Transmit_Transport_Disconnect
        method packet_start = 0


        method reason_code =
          let reason_code = Mpl_uint32.to_int32 (Mpl_uint32.at env (1)) in
          reason_code_unmarshal reason_code
        method set_reason_code v : unit =
          Mpl_uint32.marshal (env_at env (1) 4) (Mpl_uint32.of_int32 v)

        method description =
          (Mpl_string32.to_string description)
        (* set_description unsupported for now (type custom_type) *)

        method language =
          (Mpl_string32.to_string language)
        (* set_language unsupported for now (type custom_type) *)

        method packet_end = 1+4+(Mpl_string32.size description)+(Mpl_string32.size language)


        method prettyprint =
          let out = prerr_endline in
          out "[ Transport.Disconnect.transport ]";
          (* packet_start : bound *)
          (* ptype : bound *)
          out ("  reason_code = " ^ (reason_code_to_string self#reason_code));
          out ("  description = " ^ (Mpl_string32.prettyprint self#description));
          out ("  language = " ^ (Mpl_string32.prettyprint self#language));
          (* packet_end : bound *)
          ()
      end

    let t
      ~reason_code
      ~description
      ~language
      env =
        let description = (Mpl_string32.of_string description) in (* custom *)
        let language = (Mpl_string32.of_string language) in (* custom *)
        let ptype = (Mpl_byte.of_int 1) in (* const *)
        let __reason_code = reason_code_marshal reason_code in
        let __reason_code = (Mpl_uint32.of_int32 __reason_code) in
        Mpl_byte.marshal env ptype;
        Mpl_uint32.marshal env __reason_code;
        let description = Mpl_string32.marshal env description in
        let language = Mpl_string32.marshal env language in
        new o
        ~description:description
        ~language:language
        env

    let m (x:(env->o)) env = x env
    let sizeof (x:o) = x#sizeof
    let prettyprint (x:o) = x#prettyprint
    let env (x:o) = x#env
    let recv_statecall = `Receive_Transport_Disconnect
  end

  type o = [
  |`Disconnect of Disconnect.o
  |`Ignore of Ignore.o
  |`Unimplemented of Unimplemented.o
  |`Debug of Debug.o
  |`ServiceReq of ServiceReq.o
  |`ServiceAccept of ServiceAccept.o
  |`KexInit of KexInit.o
  |`NewKeys of NewKeys.o
  ]

  type x = [
  |`Disconnect of (env -> Disconnect.o)
  |`Ignore of (env -> Ignore.o)
  |`Unimplemented of (env -> Unimplemented.o)
  |`Debug of (env -> Debug.o)
  |`ServiceReq of (env -> ServiceReq.o)
  |`ServiceAccept of (env -> ServiceAccept.o)
  |`KexInit of (env -> KexInit.o)
  |`NewKeys of (env -> NewKeys.o)
  ]

  let m (x:x) env : o = match x with
  |`Disconnect (fn:(env->Disconnect.o)) -> `Disconnect (fn env)
  |`Ignore (fn:(env->Ignore.o)) -> `Ignore (fn env)
  |`Unimplemented (fn:(env->Unimplemented.o)) -> `Unimplemented (fn env)
  |`Debug (fn:(env->Debug.o)) -> `Debug (fn env)
  |`ServiceReq (fn:(env->ServiceReq.o)) -> `ServiceReq (fn env)
  |`ServiceAccept (fn:(env->ServiceAccept.o)) -> `ServiceAccept (fn env)
  |`KexInit (fn:(env->KexInit.o)) -> `KexInit (fn env)
  |`NewKeys (fn:(env->NewKeys.o)) -> `NewKeys (fn env)

  let prettyprint (x:o) = match x with
  |`Disconnect x -> x#prettyprint
  |`Ignore x -> x#prettyprint
  |`Unimplemented x -> x#prettyprint
  |`Debug x -> x#prettyprint
  |`ServiceReq x -> ServiceReq.prettyprint x
  |`ServiceAccept x -> ServiceAccept.prettyprint x
  |`KexInit x -> x#prettyprint
  |`NewKeys x -> x#prettyprint

  let sizeof (x:o) = match x with
  |`Disconnect x -> x#sizeof
  |`Ignore x -> x#sizeof
  |`Unimplemented x -> x#sizeof
  |`Debug x -> x#sizeof
  |`ServiceReq x -> ServiceReq.sizeof x
  |`ServiceAccept x -> ServiceAccept.sizeof x
  |`KexInit x -> x#sizeof
  |`NewKeys x -> x#sizeof

  let env (x:o) = match x with
  |`Disconnect x -> x#env
  |`Ignore x -> x#env
  |`Unimplemented x -> x#env
  |`Debug x -> x#env
  |`ServiceReq x -> ServiceReq.env x
  |`ServiceAccept x -> ServiceAccept.env x
  |`KexInit x -> x#env
  |`NewKeys x -> x#env

  let recv_statecall (x:o) = match x with
  |`Disconnect x -> Disconnect.recv_statecall 
  |`Ignore x -> Ignore.recv_statecall 
  |`Unimplemented x -> Unimplemented.recv_statecall 
  |`Debug x -> Debug.recv_statecall 
  |`ServiceReq x -> ServiceReq.recv_statecall x
  |`ServiceAccept x -> ServiceAccept.recv_statecall x
  |`KexInit x -> KexInit.recv_statecall 
  |`NewKeys x -> NewKeys.recv_statecall 


  let unmarshal 
    (env:env) : o =
    skip env 0; (* skipped packet_start *)
    let ptype = Mpl_byte.to_int (Mpl_byte.unmarshal env) in
    match ptype with
    |21 -> `NewKeys (
      skip env 0; (* skipped packet_end *)
      new NewKeys.o env
    )
    |20 -> `KexInit (
      skip env 16; (* skipped cookie *)
      let kex_algorithms = Mpl_string32.unmarshal env in (* custom *)
      let server_host_key_algorithms = Mpl_string32.unmarshal env in (* custom *)
      let encryption_algorithms_client_to_server = Mpl_string32.unmarshal env in (* custom *)
      let encryption_algorithms_server_to_client = Mpl_string32.unmarshal env in (* custom *)
      let mac_algorithms_client_to_server = Mpl_string32.unmarshal env in (* custom *)
      let mac_algorithms_server_to_client = Mpl_string32.unmarshal env in (* custom *)
      let compression_algorithms_client_to_server = Mpl_string32.unmarshal env in (* custom *)
      let compression_algorithms_server_to_client = Mpl_string32.unmarshal env in (* custom *)
      let languages_client_to_server = Mpl_string32.unmarshal env in (* custom *)
      let languages_server_to_client = Mpl_string32.unmarshal env in (* custom *)
      let kex_packet_follows = Mpl_boolean.unmarshal env in (* custom *)
      skip env 4; (* skipped reserved *)
      skip env 0; (* skipped packet_end *)
      new KexInit.o env
      ~kex_algorithms:kex_algorithms
      ~server_host_key_algorithms:server_host_key_algorithms
      ~encryption_algorithms_client_to_server:encryption_algorithms_client_to_server
      ~encryption_algorithms_server_to_client:encryption_algorithms_server_to_client
      ~mac_algorithms_client_to_server:mac_algorithms_client_to_server
      ~mac_algorithms_server_to_client:mac_algorithms_server_to_client
      ~compression_algorithms_client_to_server:compression_algorithms_client_to_server
      ~compression_algorithms_server_to_client:compression_algorithms_server_to_client
      ~languages_client_to_server:languages_client_to_server
      ~languages_server_to_client:languages_server_to_client
      ~kex_packet_follows:kex_packet_follows
    )
    |6 -> `ServiceAccept (
      let stype = Mpl_string32.unmarshal env in
      match (Mpl_string32.to_string stype) with
      |"ssh-connection" -> `Connection (
        skip env 0; (* skipped packet_end *)
        new ServiceAccept.Connection.o env
        ~stype:stype
      )
      |"ssh-userauth" -> `UserAuth (
        skip env 0; (* skipped packet_end *)
        new ServiceAccept.UserAuth.o env
        ~stype:stype
      )
      |x -> raise (Bad_packet (Printf.sprintf "ServiceAccept: %S" x))
    )
    |5 -> `ServiceReq (
      let stype = Mpl_string32.unmarshal env in
      match (Mpl_string32.to_string stype) with
      |"ssh-connection" -> `Connection (
        skip env 0; (* skipped packet_end *)
        new ServiceReq.Connection.o env
        ~stype:stype
      )
      |"ssh-userauth" -> `UserAuth (
        skip env 0; (* skipped packet_end *)
        new ServiceReq.UserAuth.o env
        ~stype:stype
      )
      |x -> raise (Bad_packet (Printf.sprintf "ServiceReq: %S" x))
    )
    |4 -> `Debug (
      let always_display = Mpl_boolean.unmarshal env in (* custom *)
      let message = Mpl_string32.unmarshal env in (* custom *)
      let language = Mpl_string32.unmarshal env in (* custom *)
      skip env 0; (* skipped packet_end *)
      new Debug.o env
      ~always_display:always_display
      ~message:message
      ~language:language
    )
    |3 -> `Unimplemented (
      skip env 4; (* skipped seq_num *)
      skip env 0; (* skipped packet_end *)
      new Unimplemented.o env
    )
    |2 -> `Ignore (
      let data = Mpl_string32.unmarshal env in (* custom *)
      skip env 0; (* skipped packet_end *)
      new Ignore.o env
      ~data:data
    )
    |1 -> `Disconnect (
      skip env 4; (* skipped reason_code *)
      let description = Mpl_string32.unmarshal env in (* custom *)
      let language = Mpl_string32.unmarshal env in (* custom *)
      skip env 0; (* skipped packet_end *)
      new Disconnect.o env
      ~description:description
      ~language:language
    )
    |x -> raise (Bad_packet (Printf.sprintf ": %d" x))
end

module Dhgroupsha1 = struct
  open Mpl_stdlib
  exception Bad_packet of string

  type statecalls = [
    |`Transmit_Dhgroupsha1_Init |`Receive_Dhgroupsha1_Init
    |`Transmit_Dhgroupsha1_Reply |`Receive_Dhgroupsha1_Reply
  ]

  module Reply = struct
    class o
      ~k_s
      ~f
      ~sig_h
      (env:env) =
      object(self)
        method env = env_at env 0 self#sizeof
        method sizeof = (Mpl_string32.size sig_h)+(Mpl_mpint.size f)+(Mpl_string32.size k_s)+1
        method xmit_statecall : [ `Transmit_Dhgroupsha1_Reply] = `Transmit_Dhgroupsha1_Reply

        method k_s =
          (Mpl_string32.to_string k_s)
        (* set_k_s unsupported for now (type custom_type) *)

        method f =
          (f)
        (* set_f unsupported for now (type custom_type) *)

        method sig_h =
          (Mpl_string32.to_string sig_h)
        (* set_sig_h unsupported for now (type custom_type) *)


        method prettyprint =
          let out = prerr_endline in
          out "[ Dhgroupsha1.Reply.dhgroupsha1 ]";
          (* ptype : bound *)
          out ("  k_s = " ^ (Mpl_string32.prettyprint self#k_s));
          out ("  f = " ^ (Mpl_mpint.prettyprint self#f));
          out ("  sig_h = " ^ (Mpl_string32.prettyprint self#sig_h));
          ()
      end

    let t
      ~k_s
      ~f
      ~sig_h
      env =
        let k_s = (Mpl_string32.of_string k_s) in (* custom *)
        let f = (f) in (* custom *)
        let sig_h = (Mpl_string32.of_string sig_h) in (* custom *)
        let ptype = (Mpl_byte.of_int 31) in (* const *)
        Mpl_byte.marshal env ptype;
        let k_s = Mpl_string32.marshal env k_s in
        let f = Mpl_mpint.marshal env f in
        let sig_h = Mpl_string32.marshal env sig_h in
        new o
        ~k_s:k_s
        ~f:f
        ~sig_h:sig_h
        env

    let m (x:(env->o)) env = x env
    let sizeof (x:o) = x#sizeof
    let prettyprint (x:o) = x#prettyprint
    let env (x:o) = x#env
    let recv_statecall = `Receive_Dhgroupsha1_Reply
  end

  module Init = struct
    class o
      ~e
      (env:env) =
      object(self)
        method env = env_at env 0 self#sizeof
        method sizeof = (Mpl_mpint.size e)+1
        method xmit_statecall : [ `Transmit_Dhgroupsha1_Init] = `Transmit_Dhgroupsha1_Init

        method e =
          (e)
        (* set_e unsupported for now (type custom_type) *)


        method prettyprint =
          let out = prerr_endline in
          out "[ Dhgroupsha1.Init.dhgroupsha1 ]";
          (* ptype : bound *)
          out ("  e = " ^ (Mpl_mpint.prettyprint self#e));
          ()
      end

    let t
      ~e
      env =
        let e = (e) in (* custom *)
        let ptype = (Mpl_byte.of_int 30) in (* const *)
        Mpl_byte.marshal env ptype;
        let e = Mpl_mpint.marshal env e in
        new o
        ~e:e
        env

    let m (x:(env->o)) env = x env
    let sizeof (x:o) = x#sizeof
    let prettyprint (x:o) = x#prettyprint
    let env (x:o) = x#env
    let recv_statecall = `Receive_Dhgroupsha1_Init
  end

  type o = [
  |`Init of Init.o
  |`Reply of Reply.o
  ]

  type x = [
  |`Init of (env -> Init.o)
  |`Reply of (env -> Reply.o)
  ]

  let m (x:x) env : o = match x with
  |`Init (fn:(env->Init.o)) -> `Init (fn env)
  |`Reply (fn:(env->Reply.o)) -> `Reply (fn env)

  let prettyprint (x:o) = match x with
  |`Init x -> x#prettyprint
  |`Reply x -> x#prettyprint

  let sizeof (x:o) = match x with
  |`Init x -> x#sizeof
  |`Reply x -> x#sizeof

  let env (x:o) = match x with
  |`Init x -> x#env
  |`Reply x -> x#env

  let recv_statecall (x:o) = match x with
  |`Init x -> Init.recv_statecall 
  |`Reply x -> Reply.recv_statecall 


  let unmarshal 
    (env:env) : o =
    let ptype = Mpl_byte.to_int (Mpl_byte.unmarshal env) in
    match ptype with
    |31 -> `Reply (
      let k_s = Mpl_string32.unmarshal env in (* custom *)
      let f = Mpl_mpint.unmarshal env in (* custom *)
      let sig_h = Mpl_string32.unmarshal env in (* custom *)
      new Reply.o env
      ~k_s:k_s
      ~f:f
      ~sig_h:sig_h
    )
    |30 -> `Init (
      let e = Mpl_mpint.unmarshal env in (* custom *)
      new Init.o env
      ~e:e
    )
    |x -> raise (Bad_packet (Printf.sprintf ": %d" x))
end

module Dhgexsha1 = struct
  open Mpl_stdlib
  exception Bad_packet of string

  type statecalls = [
    |`Transmit_Dhgexsha1_Request |`Receive_Dhgexsha1_Request
    |`Transmit_Dhgexsha1_Init |`Receive_Dhgexsha1_Init
    |`Transmit_Dhgexsha1_Reply |`Receive_Dhgexsha1_Reply
    |`Transmit_Dhgexsha1_Group |`Receive_Dhgexsha1_Group
  ]

  module Reply = struct
    class o
      ~k_s
      ~f
      ~sig_h
      (env:env) =
      object(self)
        method env = env_at env 0 self#sizeof
        method sizeof = (Mpl_string32.size sig_h)+(Mpl_mpint.size f)+(Mpl_string32.size k_s)+1
        method xmit_statecall : [ `Transmit_Dhgexsha1_Reply] = `Transmit_Dhgexsha1_Reply

        method k_s =
          (Mpl_string32.to_string k_s)
        (* set_k_s unsupported for now (type custom_type) *)

        method f =
          (f)
        (* set_f unsupported for now (type custom_type) *)

        method sig_h =
          (Mpl_string32.to_string sig_h)
        (* set_sig_h unsupported for now (type custom_type) *)


        method prettyprint =
          let out = prerr_endline in
          out "[ Dhgexsha1.Reply.dhgexsha1 ]";
          (* ptype : bound *)
          out ("  k_s = " ^ (Mpl_string32.prettyprint self#k_s));
          out ("  f = " ^ (Mpl_mpint.prettyprint self#f));
          out ("  sig_h = " ^ (Mpl_string32.prettyprint self#sig_h));
          ()
      end

    let t
      ~k_s
      ~f
      ~sig_h
      env =
        let k_s = (Mpl_string32.of_string k_s) in (* custom *)
        let f = (f) in (* custom *)
        let sig_h = (Mpl_string32.of_string sig_h) in (* custom *)
        let ptype = (Mpl_byte.of_int 33) in (* const *)
        Mpl_byte.marshal env ptype;
        let k_s = Mpl_string32.marshal env k_s in
        let f = Mpl_mpint.marshal env f in
        let sig_h = Mpl_string32.marshal env sig_h in
        new o
        ~k_s:k_s
        ~f:f
        ~sig_h:sig_h
        env

    let m (x:(env->o)) env = x env
    let sizeof (x:o) = x#sizeof
    let prettyprint (x:o) = x#prettyprint
    let env (x:o) = x#env
    let recv_statecall = `Receive_Dhgexsha1_Reply
  end

  module Init = struct
    class o
      ~e
      (env:env) =
      object(self)
        method env = env_at env 0 self#sizeof
        method sizeof = (Mpl_mpint.size e)+1
        method xmit_statecall : [ `Transmit_Dhgexsha1_Init] = `Transmit_Dhgexsha1_Init

        method e =
          (e)
        (* set_e unsupported for now (type custom_type) *)


        method prettyprint =
          let out = prerr_endline in
          out "[ Dhgexsha1.Init.dhgexsha1 ]";
          (* ptype : bound *)
          out ("  e = " ^ (Mpl_mpint.prettyprint self#e));
          ()
      end

    let t
      ~e
      env =
        let e = (e) in (* custom *)
        let ptype = (Mpl_byte.of_int 32) in (* const *)
        Mpl_byte.marshal env ptype;
        let e = Mpl_mpint.marshal env e in
        new o
        ~e:e
        env

    let m (x:(env->o)) env = x env
    let sizeof (x:o) = x#sizeof
    let prettyprint (x:o) = x#prettyprint
    let env (x:o) = x#env
    let recv_statecall = `Receive_Dhgexsha1_Init
  end

  module Group = struct
    class o
      ~p
      ~g
      (env:env) =
      object(self)
        method env = env_at env 0 self#sizeof
        method sizeof = (Mpl_mpint.size g)+(Mpl_mpint.size p)+1
        method xmit_statecall : [ `Transmit_Dhgexsha1_Group] = `Transmit_Dhgexsha1_Group

        method p =
          (p)
        (* set_p unsupported for now (type custom_type) *)

        method g =
          (g)
        (* set_g unsupported for now (type custom_type) *)


        method prettyprint =
          let out = prerr_endline in
          out "[ Dhgexsha1.Group.dhgexsha1 ]";
          (* ptype : bound *)
          out ("  p = " ^ (Mpl_mpint.prettyprint self#p));
          out ("  g = " ^ (Mpl_mpint.prettyprint self#g));
          ()
      end

    let t
      ~p
      ~g
      env =
        let p = (p) in (* custom *)
        let g = (g) in (* custom *)
        let ptype = (Mpl_byte.of_int 31) in (* const *)
        Mpl_byte.marshal env ptype;
        let p = Mpl_mpint.marshal env p in
        let g = Mpl_mpint.marshal env g in
        new o
        ~p:p
        ~g:g
        env

    let m (x:(env->o)) env = x env
    let sizeof (x:o) = x#sizeof
    let prettyprint (x:o) = x#prettyprint
    let env (x:o) = x#env
    let recv_statecall = `Receive_Dhgexsha1_Group
  end

  module Request = struct
    class o
      (env:env) =
      object(self)
        method env = env_at env 0 self#sizeof
        method sizeof = 4+4+4+1
        method xmit_statecall : [ `Transmit_Dhgexsha1_Request] = `Transmit_Dhgexsha1_Request

        method minv =
          Mpl_uint32.to_int32 (Mpl_uint32.at env (1))
        method set_minv v : unit =
          Mpl_uint32.marshal (env_at env (1) 4) (Mpl_uint32.of_int32 v)

        method n =
          Mpl_uint32.to_int32 (Mpl_uint32.at env (1+4))
        method set_n v : unit =
          Mpl_uint32.marshal (env_at env (1+4) 4) (Mpl_uint32.of_int32 v)

        method maxv =
          Mpl_uint32.to_int32 (Mpl_uint32.at env (1+4+4))
        method set_maxv v : unit =
          Mpl_uint32.marshal (env_at env (1+4+4) 4) (Mpl_uint32.of_int32 v)


        method prettyprint =
          let out = prerr_endline in
          out "[ Dhgexsha1.Request.dhgexsha1 ]";
          (* ptype : bound *)
          out ("  minv = " ^ (Printf.sprintf "%lu" self#minv));
          out ("  n = " ^ (Printf.sprintf "%lu" self#n));
          out ("  maxv = " ^ (Printf.sprintf "%lu" self#maxv));
          ()
      end

    let t
      ~minv
      ~n
      ~maxv
      env =
        let ptype = (Mpl_byte.of_int 34) in (* const *)
        let minv = (Mpl_uint32.of_int32 minv) in
        let n = (Mpl_uint32.of_int32 n) in
        let maxv = (Mpl_uint32.of_int32 maxv) in
        Mpl_byte.marshal env ptype;
        Mpl_uint32.marshal env minv;
        Mpl_uint32.marshal env n;
        Mpl_uint32.marshal env maxv;
        new o
        env

    let m (x:(env->o)) env = x env
    let sizeof (x:o) = x#sizeof
    let prettyprint (x:o) = x#prettyprint
    let env (x:o) = x#env
    let recv_statecall = `Receive_Dhgexsha1_Request
  end

  type o = [
  |`Request of Request.o
  |`Group of Group.o
  |`Init of Init.o
  |`Reply of Reply.o
  ]

  type x = [
  |`Request of (env -> Request.o)
  |`Group of (env -> Group.o)
  |`Init of (env -> Init.o)
  |`Reply of (env -> Reply.o)
  ]

  let m (x:x) env : o = match x with
  |`Request (fn:(env->Request.o)) -> `Request (fn env)
  |`Group (fn:(env->Group.o)) -> `Group (fn env)
  |`Init (fn:(env->Init.o)) -> `Init (fn env)
  |`Reply (fn:(env->Reply.o)) -> `Reply (fn env)

  let prettyprint (x:o) = match x with
  |`Request x -> x#prettyprint
  |`Group x -> x#prettyprint
  |`Init x -> x#prettyprint
  |`Reply x -> x#prettyprint

  let sizeof (x:o) = match x with
  |`Request x -> x#sizeof
  |`Group x -> x#sizeof
  |`Init x -> x#sizeof
  |`Reply x -> x#sizeof

  let env (x:o) = match x with
  |`Request x -> x#env
  |`Group x -> x#env
  |`Init x -> x#env
  |`Reply x -> x#env

  let recv_statecall (x:o) = match x with
  |`Request x -> Request.recv_statecall 
  |`Group x -> Group.recv_statecall 
  |`Init x -> Init.recv_statecall 
  |`Reply x -> Reply.recv_statecall 


  let unmarshal 
    (env:env) : o =
    let ptype = Mpl_byte.to_int (Mpl_byte.unmarshal env) in
    match ptype with
    |33 -> `Reply (
      let k_s = Mpl_string32.unmarshal env in (* custom *)
      let f = Mpl_mpint.unmarshal env in (* custom *)
      let sig_h = Mpl_string32.unmarshal env in (* custom *)
      new Reply.o env
      ~k_s:k_s
      ~f:f
      ~sig_h:sig_h
    )
    |32 -> `Init (
      let e = Mpl_mpint.unmarshal env in (* custom *)
      new Init.o env
      ~e:e
    )
    |31 -> `Group (
      let p = Mpl_mpint.unmarshal env in (* custom *)
      let g = Mpl_mpint.unmarshal env in (* custom *)
      new Group.o env
      ~p:p
      ~g:g
    )
    |34 -> `Request (
      skip env 4; (* skipped minv *)
      skip env 4; (* skipped n *)
      skip env 4; (* skipped maxv *)
      new Request.o env
    )
    |x -> raise (Bad_packet (Printf.sprintf ": %d" x))
end

module Auth = struct
  open Mpl_stdlib
  exception Bad_packet of string

  type statecalls = [
    |`Transmit_Auth_Req_None |`Receive_Auth_Req_None
    |`Transmit_Auth_Req_PublicKey_Request |`Receive_Auth_Req_PublicKey_Request
    |`Transmit_Auth_Banner |`Receive_Auth_Banner
    |`Transmit_Auth_PublicKey_OK |`Receive_Auth_PublicKey_OK
    |`Transmit_Auth_Failure |`Receive_Auth_Failure
    |`Transmit_Auth_ChangeReq |`Receive_Auth_ChangeReq
    |`Transmit_Auth_Req_Password_Change |`Receive_Auth_Req_Password_Change
    |`Transmit_Auth_Req_Password_Request |`Receive_Auth_Req_Password_Request
    |`Transmit_Auth_Req_PublicKey_Check |`Receive_Auth_Req_PublicKey_Check
    |`Transmit_Auth_Success |`Receive_Auth_Success
  ]

  module PublicKey_OK = struct
    class o
      ~algorithm
      ~blob
      (env:env) =
      object(self)
        method env = env_at env 0 self#sizeof
        method sizeof = (Mpl_string32.size blob)+(Mpl_string32.size algorithm)+1
        method xmit_statecall : [ `Transmit_Auth_PublicKey_OK] = `Transmit_Auth_PublicKey_OK

        method algorithm =
          (Mpl_string32.to_string algorithm)
        (* set_algorithm unsupported for now (type custom_type) *)

        method blob =
          (Mpl_string32.to_string blob)
        (* set_blob unsupported for now (type custom_type) *)


        method prettyprint =
          let out = prerr_endline in
          out "[ Auth.PublicKey_OK.auth ]";
          (* ptype : bound *)
          out ("  algorithm = " ^ (Mpl_string32.prettyprint self#algorithm));
          out ("  blob = " ^ (Mpl_string32.prettyprint self#blob));
          ()
      end

    let t
      ~algorithm
      ~blob
      env =
        let algorithm = (Mpl_string32.of_string algorithm) in (* custom *)
        let blob = (Mpl_string32.of_string blob) in (* custom *)
        let ptype = (Mpl_byte.of_int 60) in (* const *)
        Mpl_byte.marshal env ptype;
        let algorithm = Mpl_string32.marshal env algorithm in
        let blob = Mpl_string32.marshal env blob in
        new o
        ~algorithm:algorithm
        ~blob:blob
        env

    let m (x:(env->o)) env = x env
    let sizeof (x:o) = x#sizeof
    let prettyprint (x:o) = x#prettyprint
    let env (x:o) = x#env
    let recv_statecall = `Receive_Auth_PublicKey_OK
  end

  module ChangeReq = struct
    class o
      ~prompt
      ~language
      (env:env) =
      object(self)
        method env = env_at env 0 self#sizeof
        method sizeof = (Mpl_string32.size language)+(Mpl_string32.size prompt)+1
        method xmit_statecall : [ `Transmit_Auth_ChangeReq] = `Transmit_Auth_ChangeReq

        method prompt =
          (Mpl_string32.to_string prompt)
        (* set_prompt unsupported for now (type custom_type) *)

        method language =
          (Mpl_string32.to_string language)
        (* set_language unsupported for now (type custom_type) *)


        method prettyprint =
          let out = prerr_endline in
          out "[ Auth.ChangeReq.auth ]";
          (* ptype : bound *)
          out ("  prompt = " ^ (Mpl_string32.prettyprint self#prompt));
          out ("  language = " ^ (Mpl_string32.prettyprint self#language));
          ()
      end

    let t
      ~prompt
      ~language
      env =
        let prompt = (Mpl_string32.of_string prompt) in (* custom *)
        let language = (Mpl_string32.of_string language) in (* custom *)
        let ptype = (Mpl_byte.of_int 60) in (* const *)
        Mpl_byte.marshal env ptype;
        let prompt = Mpl_string32.marshal env prompt in
        let language = Mpl_string32.marshal env language in
        new o
        ~prompt:prompt
        ~language:language
        env

    let m (x:(env->o)) env = x env
    let sizeof (x:o) = x#sizeof
    let prettyprint (x:o) = x#prettyprint
    let env (x:o) = x#env
    let recv_statecall = `Receive_Auth_ChangeReq
  end

  module Banner = struct
    class o
      ~banner
      ~language
      (env:env) =
      object(self)
        method env = env_at env 0 self#sizeof
        method sizeof = (Mpl_string32.size language)+(Mpl_string32.size banner)+1
        method xmit_statecall : [ `Transmit_Auth_Banner] = `Transmit_Auth_Banner

        method banner =
          (Mpl_string32.to_string banner)
        (* set_banner unsupported for now (type custom_type) *)

        method language =
          (Mpl_string32.to_string language)
        (* set_language unsupported for now (type custom_type) *)


        method prettyprint =
          let out = prerr_endline in
          out "[ Auth.Banner.auth ]";
          (* ptype : bound *)
          out ("  banner = " ^ (Mpl_string32.prettyprint self#banner));
          out ("  language = " ^ (Mpl_string32.prettyprint self#language));
          ()
      end

    let t
      ~banner
      ~language
      env =
        let banner = (Mpl_string32.of_string banner) in (* custom *)
        let language = (Mpl_string32.of_string language) in (* custom *)
        let ptype = (Mpl_byte.of_int 53) in (* const *)
        Mpl_byte.marshal env ptype;
        let banner = Mpl_string32.marshal env banner in
        let language = Mpl_string32.marshal env language in
        new o
        ~banner:banner
        ~language:language
        env

    let m (x:(env->o)) env = x env
    let sizeof (x:o) = x#sizeof
    let prettyprint (x:o) = x#prettyprint
    let env (x:o) = x#env
    let recv_statecall = `Receive_Auth_Banner
  end

  module Success = struct
    class o
      (env:env) =
      object(self)
        method env = env_at env 0 self#sizeof
        method sizeof = 1
        method xmit_statecall : [ `Transmit_Auth_Success] = `Transmit_Auth_Success


        method prettyprint =
          let out = prerr_endline in
          out "[ Auth.Success.auth ]";
          (* ptype : bound *)
          ()
      end

    let t
      env =
        let ptype = (Mpl_byte.of_int 52) in (* const *)
        Mpl_byte.marshal env ptype;
        new o
        env

    let m (x:(env->o)) env = x env
    let sizeof (x:o) = x#sizeof
    let prettyprint (x:o) = x#prettyprint
    let env (x:o) = x#env
    let recv_statecall = `Receive_Auth_Success
  end

  module Failure = struct
    class o
      ~auth_continue
      ~partial_success
      (env:env) =
      object(self)
        method env = env_at env 0 self#sizeof
        method sizeof = 1+(Mpl_string32.size auth_continue)+1
        method xmit_statecall : [ `Transmit_Auth_Failure] = `Transmit_Auth_Failure

        method auth_continue =
          (Mpl_string32.to_string auth_continue)
        (* set_auth_continue unsupported for now (type custom_type) *)

        method partial_success =
          (Mpl_boolean.to_bool partial_success)
        (* set_partial_success unsupported for now (type custom_type) *)


        method prettyprint =
          let out = prerr_endline in
          out "[ Auth.Failure.auth ]";
          (* ptype : bound *)
          out ("  auth_continue = " ^ (Mpl_string32.prettyprint self#auth_continue));
          out ("  partial_success = " ^ (Mpl_boolean.prettyprint self#partial_success));
          ()
      end

    let t
      ~auth_continue
      ~partial_success
      env =
        let auth_continue = (Mpl_string32.of_string auth_continue) in (* custom *)
        let partial_success = (Mpl_boolean.of_bool partial_success) in (* custom *)
        let ptype = (Mpl_byte.of_int 51) in (* const *)
        Mpl_byte.marshal env ptype;
        let auth_continue = Mpl_string32.marshal env auth_continue in
        let partial_success = Mpl_boolean.marshal env partial_success in
        new o
        ~auth_continue:auth_continue
        ~partial_success:partial_success
        env

    let m (x:(env->o)) env = x env
    let sizeof (x:o) = x#sizeof
    let prettyprint (x:o) = x#prettyprint
    let env (x:o) = x#env
    let recv_statecall = `Receive_Auth_Failure
  end

  module Req = struct
    module Password = struct
      module Change = struct
        class o
          ~user_name
          ~service
          ~authtype
          ~old_password
          ~new_password
          (env:env) =
          object(self)
            method env = env_at env 0 self#sizeof
            method sizeof = (Mpl_string32.size new_password)+(Mpl_string32.size old_password)+1+(Mpl_string32.size authtype)+(Mpl_string32.size service)+(Mpl_string32.size user_name)+1
            method xmit_statecall : [ `Transmit_Auth_Req_Password_Change] = `Transmit_Auth_Req_Password_Change

            method user_name =
              (Mpl_string32.to_string user_name)
            (* set_user_name unsupported for now (type custom_type) *)

            method service =
              (Mpl_string32.to_string service)
            (* set_service unsupported for now (type custom_type) *)



            method old_password =
              (Mpl_string32.to_string old_password)
            (* set_old_password unsupported for now (type custom_type) *)

            method new_password =
              (Mpl_string32.to_string new_password)
            (* set_new_password unsupported for now (type custom_type) *)


            method prettyprint =
              let out = prerr_endline in
              out "[ Auth.Req.Password.Change.auth ]";
              (* ptype : bound *)
              out ("  user_name = " ^ (Mpl_string32.prettyprint self#user_name));
              out ("  service = " ^ (Mpl_string32.prettyprint self#service));
              (* authtype : bound *)
              (* bcheck : bound *)
              out ("  old_password = " ^ (Mpl_string32.prettyprint self#old_password));
              out ("  new_password = " ^ (Mpl_string32.prettyprint self#new_password));
              ()
          end

        let t
          ~user_name
          ~service
          ~old_password
          ~new_password
          env =
            let user_name = (Mpl_string32.of_string user_name) in (* custom *)
            let service = (Mpl_string32.of_string service) in (* custom *)
            let old_password = (Mpl_string32.of_string old_password) in (* custom *)
            let new_password = (Mpl_string32.of_string new_password) in (* custom *)
            let ptype = (Mpl_byte.of_int 50) in (* const *)
            let authtype = (Mpl_string32.of_string "password") in (* const *)
            let bcheck = (Mpl_boolean.of_bool true) in (* const *)
            Mpl_byte.marshal env ptype;
            let user_name = Mpl_string32.marshal env user_name in
            let service = Mpl_string32.marshal env service in
            let authtype = Mpl_string32.marshal env authtype in
            let bcheck = Mpl_boolean.marshal env bcheck in
            let old_password = Mpl_string32.marshal env old_password in
            let new_password = Mpl_string32.marshal env new_password in
            new o
            ~user_name:user_name
            ~service:service
            ~authtype:authtype
            ~old_password:old_password
            ~new_password:new_password
            env

        let m (x:(env->o)) env = x env
        let sizeof (x:o) = x#sizeof
        let prettyprint (x:o) = x#prettyprint
        let env (x:o) = x#env
        let recv_statecall = `Receive_Auth_Req_Password_Change
      end

      module Request = struct
        class o
          ~user_name
          ~service
          ~authtype
          ~password
          (env:env) =
          object(self)
            method env = env_at env 0 self#sizeof
            method sizeof = (Mpl_string32.size password)+1+(Mpl_string32.size authtype)+(Mpl_string32.size service)+(Mpl_string32.size user_name)+1
            method xmit_statecall : [ `Transmit_Auth_Req_Password_Request] = `Transmit_Auth_Req_Password_Request

            method user_name =
              (Mpl_string32.to_string user_name)
            (* set_user_name unsupported for now (type custom_type) *)

            method service =
              (Mpl_string32.to_string service)
            (* set_service unsupported for now (type custom_type) *)



            method password =
              (Mpl_string32.to_string password)
            (* set_password unsupported for now (type custom_type) *)


            method prettyprint =
              let out = prerr_endline in
              out "[ Auth.Req.Password.Request.auth ]";
              (* ptype : bound *)
              out ("  user_name = " ^ (Mpl_string32.prettyprint self#user_name));
              out ("  service = " ^ (Mpl_string32.prettyprint self#service));
              (* authtype : bound *)
              (* bcheck : bound *)
              out ("  password = " ^ (Mpl_string32.prettyprint self#password));
              ()
          end

        let t
          ~user_name
          ~service
          ~password
          env =
            let user_name = (Mpl_string32.of_string user_name) in (* custom *)
            let service = (Mpl_string32.of_string service) in (* custom *)
            let password = (Mpl_string32.of_string password) in (* custom *)
            let ptype = (Mpl_byte.of_int 50) in (* const *)
            let authtype = (Mpl_string32.of_string "password") in (* const *)
            let bcheck = (Mpl_boolean.of_bool false) in (* const *)
            Mpl_byte.marshal env ptype;
            let user_name = Mpl_string32.marshal env user_name in
            let service = Mpl_string32.marshal env service in
            let authtype = Mpl_string32.marshal env authtype in
            let bcheck = Mpl_boolean.marshal env bcheck in
            let password = Mpl_string32.marshal env password in
            new o
            ~user_name:user_name
            ~service:service
            ~authtype:authtype
            ~password:password
            env

        let m (x:(env->o)) env = x env
        let sizeof (x:o) = x#sizeof
        let prettyprint (x:o) = x#prettyprint
        let env (x:o) = x#env
        let recv_statecall = `Receive_Auth_Req_Password_Request
      end

      type o = [
      |`Request of Request.o
      |`Change of Change.o
      ]

      type x = [
      |`Request of (env -> Request.o)
      |`Change of (env -> Change.o)
      ]

      let m (x:x) env : o = match x with
      |`Request (fn:(env->Request.o)) -> `Request (fn env)
      |`Change (fn:(env->Change.o)) -> `Change (fn env)

      let prettyprint (x:o) = match x with
      |`Request x -> x#prettyprint
      |`Change x -> x#prettyprint

      let sizeof (x:o) = match x with
      |`Request x -> x#sizeof
      |`Change x -> x#sizeof

      let env (x:o) = match x with
      |`Request x -> x#env
      |`Change x -> x#env

      let recv_statecall (x:o) = match x with
      |`Request x -> Request.recv_statecall 
      |`Change x -> Change.recv_statecall 

    end

    module PublicKey = struct
      module Request = struct
        class o
          ~user_name
          ~service
          ~authtype
          ~algorithm
          ~publickey
          ~signature
          (env:env) =
          object(self)
            method env = env_at env 0 self#sizeof
            method sizeof = (Mpl_string32.size signature)+(Mpl_string32.size publickey)+(Mpl_string32.size algorithm)+1+(Mpl_string32.size authtype)+(Mpl_string32.size service)+(Mpl_string32.size user_name)+1
            method xmit_statecall : [ `Transmit_Auth_Req_PublicKey_Request] = `Transmit_Auth_Req_PublicKey_Request

            method user_name =
              (Mpl_string32.to_string user_name)
            (* set_user_name unsupported for now (type custom_type) *)

            method service =
              (Mpl_string32.to_string service)
            (* set_service unsupported for now (type custom_type) *)



            method algorithm =
              (Mpl_string32.to_string algorithm)
            (* set_algorithm unsupported for now (type custom_type) *)

            method publickey =
              (Mpl_string32.to_string publickey)
            (* set_publickey unsupported for now (type custom_type) *)

            method signature =
              (Mpl_string32.to_string signature)
            (* set_signature unsupported for now (type custom_type) *)


            method prettyprint =
              let out = prerr_endline in
              out "[ Auth.Req.PublicKey.Request.auth ]";
              (* ptype : bound *)
              out ("  user_name = " ^ (Mpl_string32.prettyprint self#user_name));
              out ("  service = " ^ (Mpl_string32.prettyprint self#service));
              (* authtype : bound *)
              (* bcheck : bound *)
              out ("  algorithm = " ^ (Mpl_string32.prettyprint self#algorithm));
              out ("  publickey = " ^ (Mpl_string32.prettyprint self#publickey));
              out ("  signature = " ^ (Mpl_string32.prettyprint self#signature));
              ()
          end

        let t
          ~user_name
          ~service
          ~algorithm
          ~publickey
          ~signature
          env =
            let user_name = (Mpl_string32.of_string user_name) in (* custom *)
            let service = (Mpl_string32.of_string service) in (* custom *)
            let algorithm = (Mpl_string32.of_string algorithm) in (* custom *)
            let publickey = (Mpl_string32.of_string publickey) in (* custom *)
            let signature = (Mpl_string32.of_string signature) in (* custom *)
            let ptype = (Mpl_byte.of_int 50) in (* const *)
            let authtype = (Mpl_string32.of_string "publickey") in (* const *)
            let bcheck = (Mpl_boolean.of_bool true) in (* const *)
            Mpl_byte.marshal env ptype;
            let user_name = Mpl_string32.marshal env user_name in
            let service = Mpl_string32.marshal env service in
            let authtype = Mpl_string32.marshal env authtype in
            let bcheck = Mpl_boolean.marshal env bcheck in
            let algorithm = Mpl_string32.marshal env algorithm in
            let publickey = Mpl_string32.marshal env publickey in
            let signature = Mpl_string32.marshal env signature in
            new o
            ~user_name:user_name
            ~service:service
            ~authtype:authtype
            ~algorithm:algorithm
            ~publickey:publickey
            ~signature:signature
            env

        let m (x:(env->o)) env = x env
        let sizeof (x:o) = x#sizeof
        let prettyprint (x:o) = x#prettyprint
        let env (x:o) = x#env
        let recv_statecall = `Receive_Auth_Req_PublicKey_Request
      end

      module Check = struct
        class o
          ~user_name
          ~service
          ~authtype
          ~algorithm
          ~blob
          (env:env) =
          object(self)
            method env = env_at env 0 self#sizeof
            method sizeof = (Mpl_string32.size blob)+(Mpl_string32.size algorithm)+1+(Mpl_string32.size authtype)+(Mpl_string32.size service)+(Mpl_string32.size user_name)+1
            method xmit_statecall : [ `Transmit_Auth_Req_PublicKey_Check] = `Transmit_Auth_Req_PublicKey_Check

            method user_name =
              (Mpl_string32.to_string user_name)
            (* set_user_name unsupported for now (type custom_type) *)

            method service =
              (Mpl_string32.to_string service)
            (* set_service unsupported for now (type custom_type) *)



            method algorithm =
              (Mpl_string32.to_string algorithm)
            (* set_algorithm unsupported for now (type custom_type) *)

            method blob =
              (Mpl_string32.to_string blob)
            (* set_blob unsupported for now (type custom_type) *)


            method prettyprint =
              let out = prerr_endline in
              out "[ Auth.Req.PublicKey.Check.auth ]";
              (* ptype : bound *)
              out ("  user_name = " ^ (Mpl_string32.prettyprint self#user_name));
              out ("  service = " ^ (Mpl_string32.prettyprint self#service));
              (* authtype : bound *)
              (* bcheck : bound *)
              out ("  algorithm = " ^ (Mpl_string32.prettyprint self#algorithm));
              out ("  blob = " ^ (Mpl_string32.prettyprint self#blob));
              ()
          end

        let t
          ~user_name
          ~service
          ~algorithm
          ~blob
          env =
            let user_name = (Mpl_string32.of_string user_name) in (* custom *)
            let service = (Mpl_string32.of_string service) in (* custom *)
            let algorithm = (Mpl_string32.of_string algorithm) in (* custom *)
            let blob = (Mpl_string32.of_string blob) in (* custom *)
            let ptype = (Mpl_byte.of_int 50) in (* const *)
            let authtype = (Mpl_string32.of_string "publickey") in (* const *)
            let bcheck = (Mpl_boolean.of_bool false) in (* const *)
            Mpl_byte.marshal env ptype;
            let user_name = Mpl_string32.marshal env user_name in
            let service = Mpl_string32.marshal env service in
            let authtype = Mpl_string32.marshal env authtype in
            let bcheck = Mpl_boolean.marshal env bcheck in
            let algorithm = Mpl_string32.marshal env algorithm in
            let blob = Mpl_string32.marshal env blob in
            new o
            ~user_name:user_name
            ~service:service
            ~authtype:authtype
            ~algorithm:algorithm
            ~blob:blob
            env

        let m (x:(env->o)) env = x env
        let sizeof (x:o) = x#sizeof
        let prettyprint (x:o) = x#prettyprint
        let env (x:o) = x#env
        let recv_statecall = `Receive_Auth_Req_PublicKey_Check
      end

      type o = [
      |`Check of Check.o
      |`Request of Request.o
      ]

      type x = [
      |`Check of (env -> Check.o)
      |`Request of (env -> Request.o)
      ]

      let m (x:x) env : o = match x with
      |`Check (fn:(env->Check.o)) -> `Check (fn env)
      |`Request (fn:(env->Request.o)) -> `Request (fn env)

      let prettyprint (x:o) = match x with
      |`Check x -> x#prettyprint
      |`Request x -> x#prettyprint

      let sizeof (x:o) = match x with
      |`Check x -> x#sizeof
      |`Request x -> x#sizeof

      let env (x:o) = match x with
      |`Check x -> x#env
      |`Request x -> x#env

      let recv_statecall (x:o) = match x with
      |`Check x -> Check.recv_statecall 
      |`Request x -> Request.recv_statecall 

    end

    module None = struct
      class o
        ~user_name
        ~service
        ~authtype
        (env:env) =
        object(self)
          method env = env_at env 0 self#sizeof
          method sizeof = (Mpl_string32.size authtype)+(Mpl_string32.size service)+(Mpl_string32.size user_name)+1
          method xmit_statecall : [ `Transmit_Auth_Req_None] = `Transmit_Auth_Req_None

          method user_name =
            (Mpl_string32.to_string user_name)
          (* set_user_name unsupported for now (type custom_type) *)

          method service =
            (Mpl_string32.to_string service)
          (* set_service unsupported for now (type custom_type) *)



          method prettyprint =
            let out = prerr_endline in
            out "[ Auth.Req.None.auth ]";
            (* ptype : bound *)
            out ("  user_name = " ^ (Mpl_string32.prettyprint self#user_name));
            out ("  service = " ^ (Mpl_string32.prettyprint self#service));
            (* authtype : bound *)
            ()
        end

      let t
        ~user_name
        ~service
        env =
          let user_name = (Mpl_string32.of_string user_name) in (* custom *)
          let service = (Mpl_string32.of_string service) in (* custom *)
          let ptype = (Mpl_byte.of_int 50) in (* const *)
          let authtype = (Mpl_string32.of_string "none") in (* const *)
          Mpl_byte.marshal env ptype;
          let user_name = Mpl_string32.marshal env user_name in
          let service = Mpl_string32.marshal env service in
          let authtype = Mpl_string32.marshal env authtype in
          new o
          ~user_name:user_name
          ~service:service
          ~authtype:authtype
          env

      let m (x:(env->o)) env = x env
      let sizeof (x:o) = x#sizeof
      let prettyprint (x:o) = x#prettyprint
      let env (x:o) = x#env
      let recv_statecall = `Receive_Auth_Req_None
    end

    type o = [
    |`None of None.o
    |`PublicKey of PublicKey.o
    |`Password of Password.o
    ]

    type x = [
    |`None of (env -> None.o)
    |`PublicKey of (env -> PublicKey.o)
    |`Password of (env -> Password.o)
    ]

    let m (x:x) env : o = match x with
    |`None (fn:(env->None.o)) -> `None (fn env)
    |`PublicKey (fn:(env->PublicKey.o)) -> `PublicKey (fn env)
    |`Password (fn:(env->Password.o)) -> `Password (fn env)

    let prettyprint (x:o) = match x with
    |`None x -> x#prettyprint
    |`PublicKey x -> PublicKey.prettyprint x
    |`Password x -> Password.prettyprint x

    let sizeof (x:o) = match x with
    |`None x -> x#sizeof
    |`PublicKey x -> PublicKey.sizeof x
    |`Password x -> Password.sizeof x

    let env (x:o) = match x with
    |`None x -> x#env
    |`PublicKey x -> PublicKey.env x
    |`Password x -> Password.env x

    let recv_statecall (x:o) = match x with
    |`None x -> None.recv_statecall 
    |`PublicKey x -> PublicKey.recv_statecall x
    |`Password x -> Password.recv_statecall x

  end

  type o = [
  |`Req of Req.o
  |`Failure of Failure.o
  |`Success of Success.o
  |`Banner of Banner.o
  |`ChangeReq of ChangeReq.o
  |`PublicKey_OK of PublicKey_OK.o
  ]

  type x = [
  |`Req of (env -> Req.o)
  |`Failure of (env -> Failure.o)
  |`Success of (env -> Success.o)
  |`Banner of (env -> Banner.o)
  |`ChangeReq of (env -> ChangeReq.o)
  |`PublicKey_OK of (env -> PublicKey_OK.o)
  ]

  let m (x:x) env : o = match x with
  |`Req (fn:(env->Req.o)) -> `Req (fn env)
  |`Failure (fn:(env->Failure.o)) -> `Failure (fn env)
  |`Success (fn:(env->Success.o)) -> `Success (fn env)
  |`Banner (fn:(env->Banner.o)) -> `Banner (fn env)
  |`ChangeReq (fn:(env->ChangeReq.o)) -> `ChangeReq (fn env)
  |`PublicKey_OK (fn:(env->PublicKey_OK.o)) -> `PublicKey_OK (fn env)

  let prettyprint (x:o) = match x with
  |`Req x -> Req.prettyprint x
  |`Failure x -> x#prettyprint
  |`Success x -> x#prettyprint
  |`Banner x -> x#prettyprint
  |`ChangeReq x -> x#prettyprint
  |`PublicKey_OK x -> x#prettyprint

  let sizeof (x:o) = match x with
  |`Req x -> Req.sizeof x
  |`Failure x -> x#sizeof
  |`Success x -> x#sizeof
  |`Banner x -> x#sizeof
  |`ChangeReq x -> x#sizeof
  |`PublicKey_OK x -> x#sizeof

  let env (x:o) = match x with
  |`Req x -> Req.env x
  |`Failure x -> x#env
  |`Success x -> x#env
  |`Banner x -> x#env
  |`ChangeReq x -> x#env
  |`PublicKey_OK x -> x#env

  let recv_statecall (x:o) = match x with
  |`Req x -> Req.recv_statecall x
  |`Failure x -> Failure.recv_statecall 
  |`Success x -> Success.recv_statecall 
  |`Banner x -> Banner.recv_statecall 
  |`ChangeReq x -> ChangeReq.recv_statecall 
  |`PublicKey_OK x -> PublicKey_OK.recv_statecall 


  let unmarshal 
    ~(passwd_ns:bool)
    (env:env) : o =
    let ptype = Mpl_byte.to_int (Mpl_byte.unmarshal env) in
    match ptype with
    |60 when ((not passwd_ns)) -> `PublicKey_OK (
      let algorithm = Mpl_string32.unmarshal env in (* custom *)
      let blob = Mpl_string32.unmarshal env in (* custom *)
      new PublicKey_OK.o env
      ~algorithm:algorithm
      ~blob:blob
    )
    |60 when (passwd_ns) -> `ChangeReq (
      let prompt = Mpl_string32.unmarshal env in (* custom *)
      let language = Mpl_string32.unmarshal env in (* custom *)
      new ChangeReq.o env
      ~prompt:prompt
      ~language:language
    )
    |53 -> `Banner (
      let banner = Mpl_string32.unmarshal env in (* custom *)
      let language = Mpl_string32.unmarshal env in (* custom *)
      new Banner.o env
      ~banner:banner
      ~language:language
    )
    |52 -> `Success (
      new Success.o env
    )
    |51 -> `Failure (
      let auth_continue = Mpl_string32.unmarshal env in (* custom *)
      let partial_success = Mpl_boolean.unmarshal env in (* custom *)
      new Failure.o env
      ~auth_continue:auth_continue
      ~partial_success:partial_success
    )
    |50 -> `Req (
      let user_name = Mpl_string32.unmarshal env in (* custom *)
      let service = Mpl_string32.unmarshal env in (* custom *)
      let authtype = Mpl_string32.unmarshal env in
      match (Mpl_string32.to_string authtype) with
      |"password" -> `Password (
        let bcheck = Mpl_boolean.unmarshal env in
        match (Mpl_boolean.to_bool bcheck) with
        |true -> `Change (
          let old_password = Mpl_string32.unmarshal env in (* custom *)
          let new_password = Mpl_string32.unmarshal env in (* custom *)
          new Req.Password.Change.o env
          ~user_name:user_name
          ~service:service
          ~authtype:authtype
          ~old_password:old_password
          ~new_password:new_password
        )
        |false -> `Request (
          let password = Mpl_string32.unmarshal env in (* custom *)
          new Req.Password.Request.o env
          ~user_name:user_name
          ~service:service
          ~authtype:authtype
          ~password:password
        )
        |x -> raise (Bad_packet (Printf.sprintf "Req.Password: %b" x))
      )
      |"publickey" -> `PublicKey (
        let bcheck = Mpl_boolean.unmarshal env in
        match (Mpl_boolean.to_bool bcheck) with
        |true -> `Request (
          let algorithm = Mpl_string32.unmarshal env in (* custom *)
          let publickey = Mpl_string32.unmarshal env in (* custom *)
          let signature = Mpl_string32.unmarshal env in (* custom *)
          new Req.PublicKey.Request.o env
          ~user_name:user_name
          ~service:service
          ~authtype:authtype
          ~algorithm:algorithm
          ~publickey:publickey
          ~signature:signature
        )
        |false -> `Check (
          let algorithm = Mpl_string32.unmarshal env in (* custom *)
          let blob = Mpl_string32.unmarshal env in (* custom *)
          new Req.PublicKey.Check.o env
          ~user_name:user_name
          ~service:service
          ~authtype:authtype
          ~algorithm:algorithm
          ~blob:blob
        )
        |x -> raise (Bad_packet (Printf.sprintf "Req.PublicKey: %b" x))
      )
      |"none" -> `None (
        new Req.None.o env
        ~user_name:user_name
        ~service:service
        ~authtype:authtype
      )
      |x -> raise (Bad_packet (Printf.sprintf "Req: %S" x))
    )
    |x -> raise (Bad_packet (Printf.sprintf ": %d" x))
end

module Channel = struct
  open Mpl_stdlib
  exception Bad_packet of string

  type statecalls = [
    |`Transmit_Channel_Data |`Receive_Channel_Data
    |`Transmit_Channel_GlobalRequest_TCPForward |`Receive_Channel_GlobalRequest_TCPForward
    |`Transmit_Channel_Open_DirectTCP |`Receive_Channel_Open_DirectTCP
    |`Transmit_Channel_EOF |`Receive_Channel_EOF
    |`Transmit_Channel_Request_ExitSignal |`Receive_Channel_Request_ExitSignal
    |`Transmit_Channel_RequestSuccess |`Receive_Channel_RequestSuccess
    |`Transmit_Channel_Request_X11 |`Receive_Channel_Request_X11
    |`Transmit_Channel_ExtendedData |`Receive_Channel_ExtendedData
    |`Transmit_Channel_Request_Pty |`Receive_Channel_Request_Pty
    |`Transmit_Channel_Close |`Receive_Channel_Close
    |`Transmit_Channel_WindowAdjust |`Receive_Channel_WindowAdjust
    |`Transmit_Channel_Request_Subsystem |`Receive_Channel_Request_Subsystem
    |`Transmit_Channel_Request_ExitStatus |`Receive_Channel_Request_ExitStatus
    |`Transmit_Channel_Request_Signal |`Receive_Channel_Request_Signal
    |`Transmit_Channel_Open_TCPForward |`Receive_Channel_Open_TCPForward
    |`Transmit_Channel_Failure |`Receive_Channel_Failure
    |`Transmit_Channel_RequestFailure |`Receive_Channel_RequestFailure
    |`Transmit_Channel_Open_Session |`Receive_Channel_Open_Session
    |`Transmit_Channel_Request_Exec |`Receive_Channel_Request_Exec
    |`Transmit_Channel_Request_WindowChange |`Receive_Channel_Request_WindowChange
    |`Transmit_Channel_Request_Shell |`Receive_Channel_Request_Shell
    |`Transmit_Channel_Request_LocalFlowControl |`Receive_Channel_Request_LocalFlowControl
    |`Transmit_Channel_RequestSuccessPort |`Receive_Channel_RequestSuccessPort
    |`Transmit_Channel_Open_X11 |`Receive_Channel_Open_X11
    |`Transmit_Channel_OpenFailure |`Receive_Channel_OpenFailure
    |`Transmit_Channel_Request_Env |`Receive_Channel_Request_Env
    |`Transmit_Channel_GlobalRequest_CancelTCPForward |`Receive_Channel_GlobalRequest_CancelTCPForward
    |`Transmit_Channel_OpenConfirmation |`Receive_Channel_OpenConfirmation
    |`Transmit_Channel_Success |`Receive_Channel_Success
  ]

  module Failure = struct
    class o
      (env:env) =
      object(self)
        method env = env_at env 0 self#sizeof
        method sizeof = 4+1
        method xmit_statecall : [ `Transmit_Channel_Failure] = `Transmit_Channel_Failure

        method recipient_channel =
          Mpl_uint32.to_int32 (Mpl_uint32.at env (1))
        method set_recipient_channel v : unit =
          Mpl_uint32.marshal (env_at env (1) 4) (Mpl_uint32.of_int32 v)


        method prettyprint =
          let out = prerr_endline in
          out "[ Channel.Failure.channel ]";
          (* ptype : bound *)
          out ("  recipient_channel = " ^ (Printf.sprintf "%lu" self#recipient_channel));
          ()
      end

    let t
      ~recipient_channel
      env =
        let ptype = (Mpl_byte.of_int 100) in (* const *)
        let recipient_channel = (Mpl_uint32.of_int32 recipient_channel) in
        Mpl_byte.marshal env ptype;
        Mpl_uint32.marshal env recipient_channel;
        new o
        env

    let m (x:(env->o)) env = x env
    let sizeof (x:o) = x#sizeof
    let prettyprint (x:o) = x#prettyprint
    let env (x:o) = x#env
    let recv_statecall = `Receive_Channel_Failure
  end

  module Success = struct
    class o
      (env:env) =
      object(self)
        method env = env_at env 0 self#sizeof
        method sizeof = 4+1
        method xmit_statecall : [ `Transmit_Channel_Success] = `Transmit_Channel_Success

        method recipient_channel =
          Mpl_uint32.to_int32 (Mpl_uint32.at env (1))
        method set_recipient_channel v : unit =
          Mpl_uint32.marshal (env_at env (1) 4) (Mpl_uint32.of_int32 v)


        method prettyprint =
          let out = prerr_endline in
          out "[ Channel.Success.channel ]";
          (* ptype : bound *)
          out ("  recipient_channel = " ^ (Printf.sprintf "%lu" self#recipient_channel));
          ()
      end

    let t
      ~recipient_channel
      env =
        let ptype = (Mpl_byte.of_int 99) in (* const *)
        let recipient_channel = (Mpl_uint32.of_int32 recipient_channel) in
        Mpl_byte.marshal env ptype;
        Mpl_uint32.marshal env recipient_channel;
        new o
        env

    let m (x:(env->o)) env = x env
    let sizeof (x:o) = x#sizeof
    let prettyprint (x:o) = x#prettyprint
    let env (x:o) = x#env
    let recv_statecall = `Receive_Channel_Success
  end

  module Request = struct
    module ExitSignal = struct
      class o
        ~reqtype
        ~signal
        ~core_dumped
        ~error
        ~language
        (env:env) =
        object(self)
          method env = env_at env 0 self#sizeof
          method sizeof = (Mpl_string32.size language)+(Mpl_string32.size error)+1+(Mpl_string32.size signal)+1+(Mpl_string32.size reqtype)+4+1
          method xmit_statecall : [ `Transmit_Channel_Request_ExitSignal] = `Transmit_Channel_Request_ExitSignal

          method recipient_channel =
            Mpl_uint32.to_int32 (Mpl_uint32.at env (1))
          method set_recipient_channel v : unit =
            Mpl_uint32.marshal (env_at env (1) 4) (Mpl_uint32.of_int32 v)



          method signal =
            (Mpl_string32.to_string signal)
          (* set_signal unsupported for now (type custom_type) *)

          method core_dumped =
            (Mpl_boolean.to_bool core_dumped)
          (* set_core_dumped unsupported for now (type custom_type) *)

          method error =
            (Mpl_string32.to_string error)
          (* set_error unsupported for now (type custom_type) *)

          method language =
            (Mpl_string32.to_string language)
          (* set_language unsupported for now (type custom_type) *)


          method prettyprint =
            let out = prerr_endline in
            out "[ Channel.Request.ExitSignal.channel ]";
            (* ptype : bound *)
            out ("  recipient_channel = " ^ (Printf.sprintf "%lu" self#recipient_channel));
            (* reqtype : bound *)
            (* reserved : bound *)
            out ("  signal = " ^ (Mpl_string32.prettyprint self#signal));
            out ("  core_dumped = " ^ (Mpl_boolean.prettyprint self#core_dumped));
            out ("  error = " ^ (Mpl_string32.prettyprint self#error));
            out ("  language = " ^ (Mpl_string32.prettyprint self#language));
            ()
        end

      let t
        ~recipient_channel
        ~signal
        ~core_dumped
        ~error
        ~language
        env =
          let signal = (Mpl_string32.of_string signal) in (* custom *)
          let core_dumped = (Mpl_boolean.of_bool core_dumped) in (* custom *)
          let error = (Mpl_string32.of_string error) in (* custom *)
          let language = (Mpl_string32.of_string language) in (* custom *)
          let ptype = (Mpl_byte.of_int 98) in (* const *)
          let reqtype = (Mpl_string32.of_string "exit-signal") in (* const *)
          let reserved = (Mpl_boolean.of_bool false) in (* const *)
          let recipient_channel = (Mpl_uint32.of_int32 recipient_channel) in
          Mpl_byte.marshal env ptype;
          Mpl_uint32.marshal env recipient_channel;
          let reqtype = Mpl_string32.marshal env reqtype in
          let reserved = Mpl_boolean.marshal env reserved in
          let signal = Mpl_string32.marshal env signal in
          let core_dumped = Mpl_boolean.marshal env core_dumped in
          let error = Mpl_string32.marshal env error in
          let language = Mpl_string32.marshal env language in
          new o
          ~reqtype:reqtype
          ~signal:signal
          ~core_dumped:core_dumped
          ~error:error
          ~language:language
          env

      let m (x:(env->o)) env = x env
      let sizeof (x:o) = x#sizeof
      let prettyprint (x:o) = x#prettyprint
      let env (x:o) = x#env
      let recv_statecall = `Receive_Channel_Request_ExitSignal
    end

    module ExitStatus = struct
      class o
        ~reqtype
        (env:env) =
        object(self)
          method env = env_at env 0 self#sizeof
          method sizeof = 4+1+(Mpl_string32.size reqtype)+4+1
          method xmit_statecall : [ `Transmit_Channel_Request_ExitStatus] = `Transmit_Channel_Request_ExitStatus

          method recipient_channel =
            Mpl_uint32.to_int32 (Mpl_uint32.at env (1))
          method set_recipient_channel v : unit =
            Mpl_uint32.marshal (env_at env (1) 4) (Mpl_uint32.of_int32 v)



          method exit_status =
            Mpl_uint32.to_int32 (Mpl_uint32.at env (1+4+(Mpl_string32.size reqtype)+1))
          method set_exit_status v : unit =
            Mpl_uint32.marshal (env_at env (1+4+(Mpl_string32.size reqtype)+1) 4) (Mpl_uint32.of_int32 v)


          method prettyprint =
            let out = prerr_endline in
            out "[ Channel.Request.ExitStatus.channel ]";
            (* ptype : bound *)
            out ("  recipient_channel = " ^ (Printf.sprintf "%lu" self#recipient_channel));
            (* reqtype : bound *)
            (* reserved : bound *)
            out ("  exit_status = " ^ (Printf.sprintf "%lu" self#exit_status));
            ()
        end

      let t
        ~recipient_channel
        ~exit_status
        env =
          let ptype = (Mpl_byte.of_int 98) in (* const *)
          let reqtype = (Mpl_string32.of_string "exit-status") in (* const *)
          let reserved = (Mpl_boolean.of_bool false) in (* const *)
          let recipient_channel = (Mpl_uint32.of_int32 recipient_channel) in
          let exit_status = (Mpl_uint32.of_int32 exit_status) in
          Mpl_byte.marshal env ptype;
          Mpl_uint32.marshal env recipient_channel;
          let reqtype = Mpl_string32.marshal env reqtype in
          let reserved = Mpl_boolean.marshal env reserved in
          Mpl_uint32.marshal env exit_status;
          new o
          ~reqtype:reqtype
          env

      let m (x:(env->o)) env = x env
      let sizeof (x:o) = x#sizeof
      let prettyprint (x:o) = x#prettyprint
      let env (x:o) = x#env
      let recv_statecall = `Receive_Channel_Request_ExitStatus
    end

    module Signal = struct
      class o
        ~reqtype
        ~signal
        (env:env) =
        object(self)
          method env = env_at env 0 self#sizeof
          method sizeof = (Mpl_string32.size signal)+1+(Mpl_string32.size reqtype)+4+1
          method xmit_statecall : [ `Transmit_Channel_Request_Signal] = `Transmit_Channel_Request_Signal

          method recipient_channel =
            Mpl_uint32.to_int32 (Mpl_uint32.at env (1))
          method set_recipient_channel v : unit =
            Mpl_uint32.marshal (env_at env (1) 4) (Mpl_uint32.of_int32 v)



          method signal =
            (Mpl_string32.to_string signal)
          (* set_signal unsupported for now (type custom_type) *)


          method prettyprint =
            let out = prerr_endline in
            out "[ Channel.Request.Signal.channel ]";
            (* ptype : bound *)
            out ("  recipient_channel = " ^ (Printf.sprintf "%lu" self#recipient_channel));
            (* reqtype : bound *)
            (* reserved : bound *)
            out ("  signal = " ^ (Mpl_string32.prettyprint self#signal));
            ()
        end

      let t
        ~recipient_channel
        ~signal
        env =
          let signal = (Mpl_string32.of_string signal) in (* custom *)
          let ptype = (Mpl_byte.of_int 98) in (* const *)
          let reqtype = (Mpl_string32.of_string "signal") in (* const *)
          let reserved = (Mpl_boolean.of_bool false) in (* const *)
          let recipient_channel = (Mpl_uint32.of_int32 recipient_channel) in
          Mpl_byte.marshal env ptype;
          Mpl_uint32.marshal env recipient_channel;
          let reqtype = Mpl_string32.marshal env reqtype in
          let reserved = Mpl_boolean.marshal env reserved in
          let signal = Mpl_string32.marshal env signal in
          new o
          ~reqtype:reqtype
          ~signal:signal
          env

      let m (x:(env->o)) env = x env
      let sizeof (x:o) = x#sizeof
      let prettyprint (x:o) = x#prettyprint
      let env (x:o) = x#env
      let recv_statecall = `Receive_Channel_Request_Signal
    end

    module LocalFlowControl = struct
      class o
        ~reqtype
        ~can_do
        (env:env) =
        object(self)
          method env = env_at env 0 self#sizeof
          method sizeof = 1+1+(Mpl_string32.size reqtype)+4+1
          method xmit_statecall : [ `Transmit_Channel_Request_LocalFlowControl] = `Transmit_Channel_Request_LocalFlowControl

          method recipient_channel =
            Mpl_uint32.to_int32 (Mpl_uint32.at env (1))
          method set_recipient_channel v : unit =
            Mpl_uint32.marshal (env_at env (1) 4) (Mpl_uint32.of_int32 v)



          method can_do =
            (Mpl_boolean.to_bool can_do)
          (* set_can_do unsupported for now (type custom_type) *)


          method prettyprint =
            let out = prerr_endline in
            out "[ Channel.Request.LocalFlowControl.channel ]";
            (* ptype : bound *)
            out ("  recipient_channel = " ^ (Printf.sprintf "%lu" self#recipient_channel));
            (* reqtype : bound *)
            (* reserved : bound *)
            out ("  can_do = " ^ (Mpl_boolean.prettyprint self#can_do));
            ()
        end

      let t
        ~recipient_channel
        ~can_do
        env =
          let can_do = (Mpl_boolean.of_bool can_do) in (* custom *)
          let ptype = (Mpl_byte.of_int 98) in (* const *)
          let reqtype = (Mpl_string32.of_string "xon-xoff") in (* const *)
          let reserved = (Mpl_boolean.of_bool false) in (* const *)
          let recipient_channel = (Mpl_uint32.of_int32 recipient_channel) in
          Mpl_byte.marshal env ptype;
          Mpl_uint32.marshal env recipient_channel;
          let reqtype = Mpl_string32.marshal env reqtype in
          let reserved = Mpl_boolean.marshal env reserved in
          let can_do = Mpl_boolean.marshal env can_do in
          new o
          ~reqtype:reqtype
          ~can_do:can_do
          env

      let m (x:(env->o)) env = x env
      let sizeof (x:o) = x#sizeof
      let prettyprint (x:o) = x#prettyprint
      let env (x:o) = x#env
      let recv_statecall = `Receive_Channel_Request_LocalFlowControl
    end

    module WindowChange = struct
      class o
        ~reqtype
        (env:env) =
        object(self)
          method env = env_at env 0 self#sizeof
          method sizeof = 4+4+4+4+1+(Mpl_string32.size reqtype)+4+1
          method xmit_statecall : [ `Transmit_Channel_Request_WindowChange] = `Transmit_Channel_Request_WindowChange

          method recipient_channel =
            Mpl_uint32.to_int32 (Mpl_uint32.at env (1))
          method set_recipient_channel v : unit =
            Mpl_uint32.marshal (env_at env (1) 4) (Mpl_uint32.of_int32 v)



          method col =
            Mpl_uint32.to_int32 (Mpl_uint32.at env (1+4+(Mpl_string32.size reqtype)+1))
          method set_col v : unit =
            Mpl_uint32.marshal (env_at env (1+4+(Mpl_string32.size reqtype)+1) 4) (Mpl_uint32.of_int32 v)

          method row =
            Mpl_uint32.to_int32 (Mpl_uint32.at env (1+4+(Mpl_string32.size reqtype)+1+4))
          method set_row v : unit =
            Mpl_uint32.marshal (env_at env (1+4+(Mpl_string32.size reqtype)+1+4) 4) (Mpl_uint32.of_int32 v)

          method xpixel =
            Mpl_uint32.to_int32 (Mpl_uint32.at env (1+4+(Mpl_string32.size reqtype)+1+4+4))
          method set_xpixel v : unit =
            Mpl_uint32.marshal (env_at env (1+4+(Mpl_string32.size reqtype)+1+4+4) 4) (Mpl_uint32.of_int32 v)

          method ypixel =
            Mpl_uint32.to_int32 (Mpl_uint32.at env (1+4+(Mpl_string32.size reqtype)+1+4+4+4))
          method set_ypixel v : unit =
            Mpl_uint32.marshal (env_at env (1+4+(Mpl_string32.size reqtype)+1+4+4+4) 4) (Mpl_uint32.of_int32 v)


          method prettyprint =
            let out = prerr_endline in
            out "[ Channel.Request.WindowChange.channel ]";
            (* ptype : bound *)
            out ("  recipient_channel = " ^ (Printf.sprintf "%lu" self#recipient_channel));
            (* reqtype : bound *)
            (* reserved : bound *)
            out ("  col = " ^ (Printf.sprintf "%lu" self#col));
            out ("  row = " ^ (Printf.sprintf "%lu" self#row));
            out ("  xpixel = " ^ (Printf.sprintf "%lu" self#xpixel));
            out ("  ypixel = " ^ (Printf.sprintf "%lu" self#ypixel));
            ()
        end

      let t
        ~recipient_channel
        ~col
        ~row
        ~xpixel
        ~ypixel
        env =
          let ptype = (Mpl_byte.of_int 98) in (* const *)
          let reqtype = (Mpl_string32.of_string "window-change") in (* const *)
          let reserved = (Mpl_boolean.of_bool false) in (* const *)
          let recipient_channel = (Mpl_uint32.of_int32 recipient_channel) in
          let col = (Mpl_uint32.of_int32 col) in
          let row = (Mpl_uint32.of_int32 row) in
          let xpixel = (Mpl_uint32.of_int32 xpixel) in
          let ypixel = (Mpl_uint32.of_int32 ypixel) in
          Mpl_byte.marshal env ptype;
          Mpl_uint32.marshal env recipient_channel;
          let reqtype = Mpl_string32.marshal env reqtype in
          let reserved = Mpl_boolean.marshal env reserved in
          Mpl_uint32.marshal env col;
          Mpl_uint32.marshal env row;
          Mpl_uint32.marshal env xpixel;
          Mpl_uint32.marshal env ypixel;
          new o
          ~reqtype:reqtype
          env

      let m (x:(env->o)) env = x env
      let sizeof (x:o) = x#sizeof
      let prettyprint (x:o) = x#prettyprint
      let env (x:o) = x#env
      let recv_statecall = `Receive_Channel_Request_WindowChange
    end

    module Subsystem = struct
      class o
        ~reqtype
        ~want_reply
        ~subsystem
        (env:env) =
        object(self)
          method env = env_at env 0 self#sizeof
          method sizeof = (Mpl_string32.size subsystem)+1+(Mpl_string32.size reqtype)+4+1
          method xmit_statecall : [ `Transmit_Channel_Request_Subsystem] = `Transmit_Channel_Request_Subsystem

          method recipient_channel =
            Mpl_uint32.to_int32 (Mpl_uint32.at env (1))
          method set_recipient_channel v : unit =
            Mpl_uint32.marshal (env_at env (1) 4) (Mpl_uint32.of_int32 v)


          method want_reply =
            (Mpl_boolean.to_bool want_reply)
          (* set_want_reply unsupported for now (type custom_type) *)

          method subsystem =
            (Mpl_string32.to_string subsystem)
          (* set_subsystem unsupported for now (type custom_type) *)


          method prettyprint =
            let out = prerr_endline in
            out "[ Channel.Request.Subsystem.channel ]";
            (* ptype : bound *)
            out ("  recipient_channel = " ^ (Printf.sprintf "%lu" self#recipient_channel));
            (* reqtype : bound *)
            out ("  want_reply = " ^ (Mpl_boolean.prettyprint self#want_reply));
            out ("  subsystem = " ^ (Mpl_string32.prettyprint self#subsystem));
            ()
        end

      let t
        ~recipient_channel
        ~want_reply
        ~subsystem
        env =
          let want_reply = (Mpl_boolean.of_bool want_reply) in (* custom *)
          let subsystem = (Mpl_string32.of_string subsystem) in (* custom *)
          let ptype = (Mpl_byte.of_int 98) in (* const *)
          let reqtype = (Mpl_string32.of_string "subsystem") in (* const *)
          let recipient_channel = (Mpl_uint32.of_int32 recipient_channel) in
          Mpl_byte.marshal env ptype;
          Mpl_uint32.marshal env recipient_channel;
          let reqtype = Mpl_string32.marshal env reqtype in
          let want_reply = Mpl_boolean.marshal env want_reply in
          let subsystem = Mpl_string32.marshal env subsystem in
          new o
          ~reqtype:reqtype
          ~want_reply:want_reply
          ~subsystem:subsystem
          env

      let m (x:(env->o)) env = x env
      let sizeof (x:o) = x#sizeof
      let prettyprint (x:o) = x#prettyprint
      let env (x:o) = x#env
      let recv_statecall = `Receive_Channel_Request_Subsystem
    end

    module Exec = struct
      class o
        ~reqtype
        ~want_reply
        ~command
        (env:env) =
        object(self)
          method env = env_at env 0 self#sizeof
          method sizeof = (Mpl_string32.size command)+1+(Mpl_string32.size reqtype)+4+1
          method xmit_statecall : [ `Transmit_Channel_Request_Exec] = `Transmit_Channel_Request_Exec

          method recipient_channel =
            Mpl_uint32.to_int32 (Mpl_uint32.at env (1))
          method set_recipient_channel v : unit =
            Mpl_uint32.marshal (env_at env (1) 4) (Mpl_uint32.of_int32 v)


          method want_reply =
            (Mpl_boolean.to_bool want_reply)
          (* set_want_reply unsupported for now (type custom_type) *)

          method command =
            (Mpl_string32.to_string command)
          (* set_command unsupported for now (type custom_type) *)


          method prettyprint =
            let out = prerr_endline in
            out "[ Channel.Request.Exec.channel ]";
            (* ptype : bound *)
            out ("  recipient_channel = " ^ (Printf.sprintf "%lu" self#recipient_channel));
            (* reqtype : bound *)
            out ("  want_reply = " ^ (Mpl_boolean.prettyprint self#want_reply));
            out ("  command = " ^ (Mpl_string32.prettyprint self#command));
            ()
        end

      let t
        ~recipient_channel
        ~want_reply
        ~command
        env =
          let want_reply = (Mpl_boolean.of_bool want_reply) in (* custom *)
          let command = (Mpl_string32.of_string command) in (* custom *)
          let ptype = (Mpl_byte.of_int 98) in (* const *)
          let reqtype = (Mpl_string32.of_string "exec") in (* const *)
          let recipient_channel = (Mpl_uint32.of_int32 recipient_channel) in
          Mpl_byte.marshal env ptype;
          Mpl_uint32.marshal env recipient_channel;
          let reqtype = Mpl_string32.marshal env reqtype in
          let want_reply = Mpl_boolean.marshal env want_reply in
          let command = Mpl_string32.marshal env command in
          new o
          ~reqtype:reqtype
          ~want_reply:want_reply
          ~command:command
          env

      let m (x:(env->o)) env = x env
      let sizeof (x:o) = x#sizeof
      let prettyprint (x:o) = x#prettyprint
      let env (x:o) = x#env
      let recv_statecall = `Receive_Channel_Request_Exec
    end

    module Env = struct
      class o
        ~reqtype
        ~want_reply
        ~name
        ~value
        (env:env) =
        object(self)
          method env = env_at env 0 self#sizeof
          method sizeof = (Mpl_string32.size value)+(Mpl_string32.size name)+1+(Mpl_string32.size reqtype)+4+1
          method xmit_statecall : [ `Transmit_Channel_Request_Env] = `Transmit_Channel_Request_Env

          method recipient_channel =
            Mpl_uint32.to_int32 (Mpl_uint32.at env (1))
          method set_recipient_channel v : unit =
            Mpl_uint32.marshal (env_at env (1) 4) (Mpl_uint32.of_int32 v)


          method want_reply =
            (Mpl_boolean.to_bool want_reply)
          (* set_want_reply unsupported for now (type custom_type) *)

          method name =
            (Mpl_string32.to_string name)
          (* set_name unsupported for now (type custom_type) *)

          method value =
            (Mpl_string32.to_string value)
          (* set_value unsupported for now (type custom_type) *)


          method prettyprint =
            let out = prerr_endline in
            out "[ Channel.Request.Env.channel ]";
            (* ptype : bound *)
            out ("  recipient_channel = " ^ (Printf.sprintf "%lu" self#recipient_channel));
            (* reqtype : bound *)
            out ("  want_reply = " ^ (Mpl_boolean.prettyprint self#want_reply));
            out ("  name = " ^ (Mpl_string32.prettyprint self#name));
            out ("  value = " ^ (Mpl_string32.prettyprint self#value));
            ()
        end

      let t
        ~recipient_channel
        ~want_reply
        ~name
        ~value
        env =
          let want_reply = (Mpl_boolean.of_bool want_reply) in (* custom *)
          let name = (Mpl_string32.of_string name) in (* custom *)
          let value = (Mpl_string32.of_string value) in (* custom *)
          let ptype = (Mpl_byte.of_int 98) in (* const *)
          let reqtype = (Mpl_string32.of_string "env") in (* const *)
          let recipient_channel = (Mpl_uint32.of_int32 recipient_channel) in
          Mpl_byte.marshal env ptype;
          Mpl_uint32.marshal env recipient_channel;
          let reqtype = Mpl_string32.marshal env reqtype in
          let want_reply = Mpl_boolean.marshal env want_reply in
          let name = Mpl_string32.marshal env name in
          let value = Mpl_string32.marshal env value in
          new o
          ~reqtype:reqtype
          ~want_reply:want_reply
          ~name:name
          ~value:value
          env

      let m (x:(env->o)) env = x env
      let sizeof (x:o) = x#sizeof
      let prettyprint (x:o) = x#prettyprint
      let env (x:o) = x#env
      let recv_statecall = `Receive_Channel_Request_Env
    end

    module Shell = struct
      class o
        ~reqtype
        ~want_reply
        (env:env) =
        object(self)
          method env = env_at env 0 self#sizeof
          method sizeof = 1+(Mpl_string32.size reqtype)+4+1
          method xmit_statecall : [ `Transmit_Channel_Request_Shell] = `Transmit_Channel_Request_Shell

          method recipient_channel =
            Mpl_uint32.to_int32 (Mpl_uint32.at env (1))
          method set_recipient_channel v : unit =
            Mpl_uint32.marshal (env_at env (1) 4) (Mpl_uint32.of_int32 v)


          method want_reply =
            (Mpl_boolean.to_bool want_reply)
          (* set_want_reply unsupported for now (type custom_type) *)


          method prettyprint =
            let out = prerr_endline in
            out "[ Channel.Request.Shell.channel ]";
            (* ptype : bound *)
            out ("  recipient_channel = " ^ (Printf.sprintf "%lu" self#recipient_channel));
            (* reqtype : bound *)
            out ("  want_reply = " ^ (Mpl_boolean.prettyprint self#want_reply));
            ()
        end

      let t
        ~recipient_channel
        ~want_reply
        env =
          let want_reply = (Mpl_boolean.of_bool want_reply) in (* custom *)
          let ptype = (Mpl_byte.of_int 98) in (* const *)
          let reqtype = (Mpl_string32.of_string "shell") in (* const *)
          let recipient_channel = (Mpl_uint32.of_int32 recipient_channel) in
          Mpl_byte.marshal env ptype;
          Mpl_uint32.marshal env recipient_channel;
          let reqtype = Mpl_string32.marshal env reqtype in
          let want_reply = Mpl_boolean.marshal env want_reply in
          new o
          ~reqtype:reqtype
          ~want_reply:want_reply
          env

      let m (x:(env->o)) env = x env
      let sizeof (x:o) = x#sizeof
      let prettyprint (x:o) = x#prettyprint
      let env (x:o) = x#env
      let recv_statecall = `Receive_Channel_Request_Shell
    end

    module X11 = struct
      class o
        ~reqtype
        ~auth_cookie
        (env:env) =
        object(self)
          method env = env_at env 0 self#sizeof
          method sizeof = 4+(Mpl_string32.size auth_cookie)+(Mpl_string32.size reqtype)+4+1
          method xmit_statecall : [ `Transmit_Channel_Request_X11] = `Transmit_Channel_Request_X11

          method recipient_channel =
            Mpl_uint32.to_int32 (Mpl_uint32.at env (1))
          method set_recipient_channel v : unit =
            Mpl_uint32.marshal (env_at env (1) 4) (Mpl_uint32.of_int32 v)


          method auth_cookie =
            (Mpl_string32.to_string auth_cookie)
          (* set_auth_cookie unsupported for now (type custom_type) *)

          method screen =
            Mpl_uint32.to_int32 (Mpl_uint32.at env (1+4+(Mpl_string32.size reqtype)+(Mpl_string32.size auth_cookie)))
          method set_screen v : unit =
            Mpl_uint32.marshal (env_at env (1+4+(Mpl_string32.size reqtype)+(Mpl_string32.size auth_cookie)) 4) (Mpl_uint32.of_int32 v)


          method prettyprint =
            let out = prerr_endline in
            out "[ Channel.Request.X11.channel ]";
            (* ptype : bound *)
            out ("  recipient_channel = " ^ (Printf.sprintf "%lu" self#recipient_channel));
            (* reqtype : bound *)
            out ("  auth_cookie = " ^ (Mpl_string32.prettyprint self#auth_cookie));
            out ("  screen = " ^ (Printf.sprintf "%lu" self#screen));
            ()
        end

      let t
        ~recipient_channel
        ~auth_cookie
        ~screen
        env =
          let auth_cookie = (Mpl_string32.of_string auth_cookie) in (* custom *)
          let ptype = (Mpl_byte.of_int 98) in (* const *)
          let reqtype = (Mpl_string32.of_string "x11-req") in (* const *)
          let recipient_channel = (Mpl_uint32.of_int32 recipient_channel) in
          let screen = (Mpl_uint32.of_int32 screen) in
          Mpl_byte.marshal env ptype;
          Mpl_uint32.marshal env recipient_channel;
          let reqtype = Mpl_string32.marshal env reqtype in
          let auth_cookie = Mpl_string32.marshal env auth_cookie in
          Mpl_uint32.marshal env screen;
          new o
          ~reqtype:reqtype
          ~auth_cookie:auth_cookie
          env

      let m (x:(env->o)) env = x env
      let sizeof (x:o) = x#sizeof
      let prettyprint (x:o) = x#prettyprint
      let env (x:o) = x#env
      let recv_statecall = `Receive_Channel_Request_X11
    end

    module Pty = struct
      class o
        ~reqtype
        ~want_reply
        ~term
        (env:env) =
        object(self)
          method env = env_at env 0 self#sizeof
          method sizeof = 4+4+4+4+(Mpl_string32.size term)+1+(Mpl_string32.size reqtype)+4+1
          method xmit_statecall : [ `Transmit_Channel_Request_Pty] = `Transmit_Channel_Request_Pty

          method recipient_channel =
            Mpl_uint32.to_int32 (Mpl_uint32.at env (1))
          method set_recipient_channel v : unit =
            Mpl_uint32.marshal (env_at env (1) 4) (Mpl_uint32.of_int32 v)


          method want_reply =
            (Mpl_boolean.to_bool want_reply)
          (* set_want_reply unsupported for now (type custom_type) *)

          method term =
            (Mpl_string32.to_string term)
          (* set_term unsupported for now (type custom_type) *)

          method width_chars =
            Mpl_uint32.to_int32 (Mpl_uint32.at env (1+4+(Mpl_string32.size reqtype)+1+(Mpl_string32.size term)))
          method set_width_chars v : unit =
            Mpl_uint32.marshal (env_at env (1+4+(Mpl_string32.size reqtype)+1+(Mpl_string32.size term)) 4) (Mpl_uint32.of_int32 v)

          method height_rows =
            Mpl_uint32.to_int32 (Mpl_uint32.at env (1+4+(Mpl_string32.size reqtype)+1+(Mpl_string32.size term)+4))
          method set_height_rows v : unit =
            Mpl_uint32.marshal (env_at env (1+4+(Mpl_string32.size reqtype)+1+(Mpl_string32.size term)+4) 4) (Mpl_uint32.of_int32 v)

          method width_pixels =
            Mpl_uint32.to_int32 (Mpl_uint32.at env (1+4+(Mpl_string32.size reqtype)+1+(Mpl_string32.size term)+4+4))
          method set_width_pixels v : unit =
            Mpl_uint32.marshal (env_at env (1+4+(Mpl_string32.size reqtype)+1+(Mpl_string32.size term)+4+4) 4) (Mpl_uint32.of_int32 v)

          method height_pixels =
            Mpl_uint32.to_int32 (Mpl_uint32.at env (1+4+(Mpl_string32.size reqtype)+1+(Mpl_string32.size term)+4+4+4))
          method set_height_pixels v : unit =
            Mpl_uint32.marshal (env_at env (1+4+(Mpl_string32.size reqtype)+1+(Mpl_string32.size term)+4+4+4) 4) (Mpl_uint32.of_int32 v)


          method prettyprint =
            let out = prerr_endline in
            out "[ Channel.Request.Pty.channel ]";
            (* ptype : bound *)
            out ("  recipient_channel = " ^ (Printf.sprintf "%lu" self#recipient_channel));
            (* reqtype : bound *)
            out ("  want_reply = " ^ (Mpl_boolean.prettyprint self#want_reply));
            out ("  term = " ^ (Mpl_string32.prettyprint self#term));
            out ("  width_chars = " ^ (Printf.sprintf "%lu" self#width_chars));
            out ("  height_rows = " ^ (Printf.sprintf "%lu" self#height_rows));
            out ("  width_pixels = " ^ (Printf.sprintf "%lu" self#width_pixels));
            out ("  height_pixels = " ^ (Printf.sprintf "%lu" self#height_pixels));
            ()
        end

      let t
        ~recipient_channel
        ~want_reply
        ~term
        ~width_chars
        ~height_rows
        ~width_pixels
        ~height_pixels
        env =
          let want_reply = (Mpl_boolean.of_bool want_reply) in (* custom *)
          let term = (Mpl_string32.of_string term) in (* custom *)
          let ptype = (Mpl_byte.of_int 98) in (* const *)
          let reqtype = (Mpl_string32.of_string "pty-req") in (* const *)
          let recipient_channel = (Mpl_uint32.of_int32 recipient_channel) in
          let width_chars = (Mpl_uint32.of_int32 width_chars) in
          let height_rows = (Mpl_uint32.of_int32 height_rows) in
          let width_pixels = (Mpl_uint32.of_int32 width_pixels) in
          let height_pixels = (Mpl_uint32.of_int32 height_pixels) in
          Mpl_byte.marshal env ptype;
          Mpl_uint32.marshal env recipient_channel;
          let reqtype = Mpl_string32.marshal env reqtype in
          let want_reply = Mpl_boolean.marshal env want_reply in
          let term = Mpl_string32.marshal env term in
          Mpl_uint32.marshal env width_chars;
          Mpl_uint32.marshal env height_rows;
          Mpl_uint32.marshal env width_pixels;
          Mpl_uint32.marshal env height_pixels;
          new o
          ~reqtype:reqtype
          ~want_reply:want_reply
          ~term:term
          env

      let m (x:(env->o)) env = x env
      let sizeof (x:o) = x#sizeof
      let prettyprint (x:o) = x#prettyprint
      let env (x:o) = x#env
      let recv_statecall = `Receive_Channel_Request_Pty
    end

    type o = [
    |`Pty of Pty.o
    |`X11 of X11.o
    |`Shell of Shell.o
    |`Env of Env.o
    |`Exec of Exec.o
    |`Subsystem of Subsystem.o
    |`WindowChange of WindowChange.o
    |`LocalFlowControl of LocalFlowControl.o
    |`Signal of Signal.o
    |`ExitStatus of ExitStatus.o
    |`ExitSignal of ExitSignal.o
    ]

    type x = [
    |`Pty of (env -> Pty.o)
    |`X11 of (env -> X11.o)
    |`Shell of (env -> Shell.o)
    |`Env of (env -> Env.o)
    |`Exec of (env -> Exec.o)
    |`Subsystem of (env -> Subsystem.o)
    |`WindowChange of (env -> WindowChange.o)
    |`LocalFlowControl of (env -> LocalFlowControl.o)
    |`Signal of (env -> Signal.o)
    |`ExitStatus of (env -> ExitStatus.o)
    |`ExitSignal of (env -> ExitSignal.o)
    ]

    let m (x:x) env : o = match x with
    |`Pty (fn:(env->Pty.o)) -> `Pty (fn env)
    |`X11 (fn:(env->X11.o)) -> `X11 (fn env)
    |`Shell (fn:(env->Shell.o)) -> `Shell (fn env)
    |`Env (fn:(env->Env.o)) -> `Env (fn env)
    |`Exec (fn:(env->Exec.o)) -> `Exec (fn env)
    |`Subsystem (fn:(env->Subsystem.o)) -> `Subsystem (fn env)
    |`WindowChange (fn:(env->WindowChange.o)) -> `WindowChange (fn env)
    |`LocalFlowControl (fn:(env->LocalFlowControl.o)) -> `LocalFlowControl (fn env)
    |`Signal (fn:(env->Signal.o)) -> `Signal (fn env)
    |`ExitStatus (fn:(env->ExitStatus.o)) -> `ExitStatus (fn env)
    |`ExitSignal (fn:(env->ExitSignal.o)) -> `ExitSignal (fn env)

    let prettyprint (x:o) = match x with
    |`Pty x -> x#prettyprint
    |`X11 x -> x#prettyprint
    |`Shell x -> x#prettyprint
    |`Env x -> x#prettyprint
    |`Exec x -> x#prettyprint
    |`Subsystem x -> x#prettyprint
    |`WindowChange x -> x#prettyprint
    |`LocalFlowControl x -> x#prettyprint
    |`Signal x -> x#prettyprint
    |`ExitStatus x -> x#prettyprint
    |`ExitSignal x -> x#prettyprint

    let sizeof (x:o) = match x with
    |`Pty x -> x#sizeof
    |`X11 x -> x#sizeof
    |`Shell x -> x#sizeof
    |`Env x -> x#sizeof
    |`Exec x -> x#sizeof
    |`Subsystem x -> x#sizeof
    |`WindowChange x -> x#sizeof
    |`LocalFlowControl x -> x#sizeof
    |`Signal x -> x#sizeof
    |`ExitStatus x -> x#sizeof
    |`ExitSignal x -> x#sizeof

    let env (x:o) = match x with
    |`Pty x -> x#env
    |`X11 x -> x#env
    |`Shell x -> x#env
    |`Env x -> x#env
    |`Exec x -> x#env
    |`Subsystem x -> x#env
    |`WindowChange x -> x#env
    |`LocalFlowControl x -> x#env
    |`Signal x -> x#env
    |`ExitStatus x -> x#env
    |`ExitSignal x -> x#env

    let recv_statecall (x:o) = match x with
    |`Pty x -> Pty.recv_statecall 
    |`X11 x -> X11.recv_statecall 
    |`Shell x -> Shell.recv_statecall 
    |`Env x -> Env.recv_statecall 
    |`Exec x -> Exec.recv_statecall 
    |`Subsystem x -> Subsystem.recv_statecall 
    |`WindowChange x -> WindowChange.recv_statecall 
    |`LocalFlowControl x -> LocalFlowControl.recv_statecall 
    |`Signal x -> Signal.recv_statecall 
    |`ExitStatus x -> ExitStatus.recv_statecall 
    |`ExitSignal x -> ExitSignal.recv_statecall 

  end

  module Close = struct
    class o
      (env:env) =
      object(self)
        method env = env_at env 0 self#sizeof
        method sizeof = 4+1
        method xmit_statecall : [ `Transmit_Channel_Close] = `Transmit_Channel_Close

        method recipient_channel =
          Mpl_uint32.to_int32 (Mpl_uint32.at env (1))
        method set_recipient_channel v : unit =
          Mpl_uint32.marshal (env_at env (1) 4) (Mpl_uint32.of_int32 v)


        method prettyprint =
          let out = prerr_endline in
          out "[ Channel.Close.channel ]";
          (* ptype : bound *)
          out ("  recipient_channel = " ^ (Printf.sprintf "%lu" self#recipient_channel));
          ()
      end

    let t
      ~recipient_channel
      env =
        let ptype = (Mpl_byte.of_int 97) in (* const *)
        let recipient_channel = (Mpl_uint32.of_int32 recipient_channel) in
        Mpl_byte.marshal env ptype;
        Mpl_uint32.marshal env recipient_channel;
        new o
        env

    let m (x:(env->o)) env = x env
    let sizeof (x:o) = x#sizeof
    let prettyprint (x:o) = x#prettyprint
    let env (x:o) = x#env
    let recv_statecall = `Receive_Channel_Close
  end

  module EOF = struct
    class o
      (env:env) =
      object(self)
        method env = env_at env 0 self#sizeof
        method sizeof = 4+1
        method xmit_statecall : [ `Transmit_Channel_EOF] = `Transmit_Channel_EOF

        method recipient_channel =
          Mpl_uint32.to_int32 (Mpl_uint32.at env (1))
        method set_recipient_channel v : unit =
          Mpl_uint32.marshal (env_at env (1) 4) (Mpl_uint32.of_int32 v)


        method prettyprint =
          let out = prerr_endline in
          out "[ Channel.EOF.channel ]";
          (* ptype : bound *)
          out ("  recipient_channel = " ^ (Printf.sprintf "%lu" self#recipient_channel));
          ()
      end

    let t
      ~recipient_channel
      env =
        let ptype = (Mpl_byte.of_int 96) in (* const *)
        let recipient_channel = (Mpl_uint32.of_int32 recipient_channel) in
        Mpl_byte.marshal env ptype;
        Mpl_uint32.marshal env recipient_channel;
        new o
        env

    let m (x:(env->o)) env = x env
    let sizeof (x:o) = x#sizeof
    let prettyprint (x:o) = x#prettyprint
    let env (x:o) = x#env
    let recv_statecall = `Receive_Channel_EOF
  end

  module ExtendedData = struct
    type data_type_t = [
      |`Stderr
      |`Unknown of int32
    ]

    let data_type_marshal (a:data_type_t) =
      match a with
      |`Stderr -> 1l
      |`Unknown x -> x

    let data_type_unmarshal a : data_type_t =
      match a with
      |1l -> `Stderr
      |x -> `Unknown x

    let data_type_to_string (a:data_type_t) =
      match a with
      |`Stderr -> "Stderr"
      |`Unknown x -> Printf.sprintf "%ld" x

    let data_type_of_string s : data_type_t option = match s with
      |"Stderr" -> Some `Stderr
      |_ -> None

    class o
      ~(data_length:int)
      (env:env) =
      object(self)
        method env = env_at env 0 self#sizeof
        method sizeof = data_length+4+4+4+1
        method xmit_statecall : [ `Transmit_Channel_ExtendedData] = `Transmit_Channel_ExtendedData

        method recipient_channel =
          Mpl_uint32.to_int32 (Mpl_uint32.at env (1))
        method set_recipient_channel v : unit =
          Mpl_uint32.marshal (env_at env (1) 4) (Mpl_uint32.of_int32 v)

        method data_type =
          let data_type = Mpl_uint32.to_int32 (Mpl_uint32.at env (1+4)) in
          data_type_unmarshal data_type
        method set_data_type v : unit =
          Mpl_uint32.marshal (env_at env (1+4) 4) (Mpl_uint32.of_int32 v)


        method data =
          Mpl_raw.at env (1+4+4+4) data_length
        (* set_data unsupported for now (type byte array) *)
        method data_env : env = env_at env (1+4+4+4) data_length
        method data_frag = Mpl_raw.frag env (1+4+4+4) data_length
        method data_length = data_length


        method prettyprint =
          let out = prerr_endline in
          out "[ Channel.ExtendedData.channel ]";
          (* ptype : bound *)
          out ("  recipient_channel = " ^ (Printf.sprintf "%lu" self#recipient_channel));
          out ("  data_type = " ^ (data_type_to_string self#data_type));
          (* datalen : bound *)
          out ("  data = " ^ (Mpl_raw.prettyprint self#data));
          ()
      end

    let t
      ~recipient_channel
      ?(data_type=`Stderr)
      ~(data:data)
      env =
        let ___env = env_at env (1+4+4+4) 0 in
        let data___len = match data with 
        |`Str x -> Mpl_raw.marshal ___env x; String.length x
        |`Sub fn -> fn ___env; curpos ___env
        |`None -> 0
        |`Frag t -> Mpl_raw.blit ___env t; curpos ___env in
        let data___sizeof = data___len in
        let ptype = (Mpl_byte.of_int 95) in (* const *)
        let datalen = (Mpl_uint32.of_int32 (Int32.of_int data___sizeof)) in (* bound *)
        let recipient_channel = (Mpl_uint32.of_int32 recipient_channel) in
        let __data_type = data_type_marshal data_type in
        let __data_type = (Mpl_uint32.of_int32 __data_type) in
        let data = data in
        Mpl_byte.marshal env ptype;
        Mpl_uint32.marshal env recipient_channel;
        Mpl_uint32.marshal env __data_type;
        Mpl_uint32.marshal env datalen;
        skip env data___len;
        new o
        ~data_length:data___len
        env

    let m (x:(env->o)) env = x env
    let sizeof (x:o) = x#sizeof
    let prettyprint (x:o) = x#prettyprint
    let env (x:o) = x#env
    let recv_statecall = `Receive_Channel_ExtendedData
  end

  module Data = struct
    class o
      ~(data_length:int)
      (env:env) =
      object(self)
        method env = env_at env 0 self#sizeof
        method sizeof = data_length+4+4+1
        method xmit_statecall : [ `Transmit_Channel_Data] = `Transmit_Channel_Data

        method recipient_channel =
          Mpl_uint32.to_int32 (Mpl_uint32.at env (1))
        method set_recipient_channel v : unit =
          Mpl_uint32.marshal (env_at env (1) 4) (Mpl_uint32.of_int32 v)


        method data =
          Mpl_raw.at env (1+4+4) data_length
        (* set_data unsupported for now (type byte array) *)
        method data_env : env = env_at env (1+4+4) data_length
        method data_frag = Mpl_raw.frag env (1+4+4) data_length
        method data_length = data_length


        method prettyprint =
          let out = prerr_endline in
          out "[ Channel.Data.channel ]";
          (* ptype : bound *)
          out ("  recipient_channel = " ^ (Printf.sprintf "%lu" self#recipient_channel));
          (* datalen : bound *)
          out ("  data = " ^ (Mpl_raw.prettyprint self#data));
          ()
      end

    let t
      ~recipient_channel
      ~(data:data)
      env =
        let ___env = env_at env (1+4+4) 0 in
        let data___len = match data with 
        |`Str x -> Mpl_raw.marshal ___env x; String.length x
        |`Sub fn -> fn ___env; curpos ___env
        |`None -> 0
        |`Frag t -> Mpl_raw.blit ___env t; curpos ___env in
        let data___sizeof = data___len in
        let ptype = (Mpl_byte.of_int 94) in (* const *)
        let datalen = (Mpl_uint32.of_int32 (Int32.of_int data___sizeof)) in (* bound *)
        let recipient_channel = (Mpl_uint32.of_int32 recipient_channel) in
        let data = data in
        Mpl_byte.marshal env ptype;
        Mpl_uint32.marshal env recipient_channel;
        Mpl_uint32.marshal env datalen;
        skip env data___len;
        new o
        ~data_length:data___len
        env

    let m (x:(env->o)) env = x env
    let sizeof (x:o) = x#sizeof
    let prettyprint (x:o) = x#prettyprint
    let env (x:o) = x#env
    let recv_statecall = `Receive_Channel_Data
  end

  module WindowAdjust = struct
    class o
      (env:env) =
      object(self)
        method env = env_at env 0 self#sizeof
        method sizeof = 4+4+1
        method xmit_statecall : [ `Transmit_Channel_WindowAdjust] = `Transmit_Channel_WindowAdjust

        method recipient_channel =
          Mpl_uint32.to_int32 (Mpl_uint32.at env (1))
        method set_recipient_channel v : unit =
          Mpl_uint32.marshal (env_at env (1) 4) (Mpl_uint32.of_int32 v)

        method bytes_to_add =
          Mpl_uint32.to_int32 (Mpl_uint32.at env (1+4))
        method set_bytes_to_add v : unit =
          Mpl_uint32.marshal (env_at env (1+4) 4) (Mpl_uint32.of_int32 v)


        method prettyprint =
          let out = prerr_endline in
          out "[ Channel.WindowAdjust.channel ]";
          (* ptype : bound *)
          out ("  recipient_channel = " ^ (Printf.sprintf "%lu" self#recipient_channel));
          out ("  bytes_to_add = " ^ (Printf.sprintf "%lu" self#bytes_to_add));
          ()
      end

    let t
      ~recipient_channel
      ~bytes_to_add
      env =
        let ptype = (Mpl_byte.of_int 93) in (* const *)
        let recipient_channel = (Mpl_uint32.of_int32 recipient_channel) in
        let bytes_to_add = (Mpl_uint32.of_int32 bytes_to_add) in
        Mpl_byte.marshal env ptype;
        Mpl_uint32.marshal env recipient_channel;
        Mpl_uint32.marshal env bytes_to_add;
        new o
        env

    let m (x:(env->o)) env = x env
    let sizeof (x:o) = x#sizeof
    let prettyprint (x:o) = x#prettyprint
    let env (x:o) = x#env
    let recv_statecall = `Receive_Channel_WindowAdjust
  end

  module OpenFailure = struct
    type reason_code_t = [
      |`Prohibited
      |`Connect_failed
      |`Unknown_type
      |`Resource_shortage
      |`Unknown of int32
    ]

    let reason_code_marshal (a:reason_code_t) =
      match a with
      |`Prohibited -> 1l
      |`Connect_failed -> 2l
      |`Unknown_type -> 3l
      |`Resource_shortage -> 4l
      |`Unknown x -> x

    let reason_code_unmarshal a : reason_code_t =
      match a with
      |1l -> `Prohibited
      |2l -> `Connect_failed
      |3l -> `Unknown_type
      |4l -> `Resource_shortage
      |x -> `Unknown x

    let reason_code_to_string (a:reason_code_t) =
      match a with
      |`Prohibited -> "Prohibited"
      |`Connect_failed -> "Connect_failed"
      |`Unknown_type -> "Unknown_type"
      |`Resource_shortage -> "Resource_shortage"
      |`Unknown x -> Printf.sprintf "%ld" x

    let reason_code_of_string s : reason_code_t option = match s with
      |"Prohibited" -> Some `Prohibited
      |"Connect_failed" -> Some `Connect_failed
      |"Unknown_type" -> Some `Unknown_type
      |"Resource_shortage" -> Some `Resource_shortage
      |_ -> None

    class o
      ~information
      ~language
      (env:env) =
      object(self)
        method env = env_at env 0 self#sizeof
        method sizeof = (Mpl_string32.size language)+(Mpl_string32.size information)+4+4+1
        method xmit_statecall : [ `Transmit_Channel_OpenFailure] = `Transmit_Channel_OpenFailure

        method recipient_channel =
          Mpl_uint32.to_int32 (Mpl_uint32.at env (1))
        method set_recipient_channel v : unit =
          Mpl_uint32.marshal (env_at env (1) 4) (Mpl_uint32.of_int32 v)

        method reason_code =
          let reason_code = Mpl_uint32.to_int32 (Mpl_uint32.at env (1+4)) in
          reason_code_unmarshal reason_code
        method set_reason_code v : unit =
          Mpl_uint32.marshal (env_at env (1+4) 4) (Mpl_uint32.of_int32 v)

        method information =
          (Mpl_string32.to_string information)
        (* set_information unsupported for now (type custom_type) *)

        method language =
          (Mpl_string32.to_string language)
        (* set_language unsupported for now (type custom_type) *)


        method prettyprint =
          let out = prerr_endline in
          out "[ Channel.OpenFailure.channel ]";
          (* ptype : bound *)
          out ("  recipient_channel = " ^ (Printf.sprintf "%lu" self#recipient_channel));
          out ("  reason_code = " ^ (reason_code_to_string self#reason_code));
          out ("  information = " ^ (Mpl_string32.prettyprint self#information));
          out ("  language = " ^ (Mpl_string32.prettyprint self#language));
          ()
      end

    let t
      ~recipient_channel
      ~reason_code
      ~information
      ~language
      env =
        let information = (Mpl_string32.of_string information) in (* custom *)
        let language = (Mpl_string32.of_string language) in (* custom *)
        let ptype = (Mpl_byte.of_int 92) in (* const *)
        let recipient_channel = (Mpl_uint32.of_int32 recipient_channel) in
        let __reason_code = reason_code_marshal reason_code in
        let __reason_code = (Mpl_uint32.of_int32 __reason_code) in
        Mpl_byte.marshal env ptype;
        Mpl_uint32.marshal env recipient_channel;
        Mpl_uint32.marshal env __reason_code;
        let information = Mpl_string32.marshal env information in
        let language = Mpl_string32.marshal env language in
        new o
        ~information:information
        ~language:language
        env

    let m (x:(env->o)) env = x env
    let sizeof (x:o) = x#sizeof
    let prettyprint (x:o) = x#prettyprint
    let env (x:o) = x#env
    let recv_statecall = `Receive_Channel_OpenFailure
  end

  module OpenConfirmation = struct
    class o
      (env:env) =
      object(self)
        method env = env_at env 0 self#sizeof
        method sizeof = 4+4+4+4+1
        method xmit_statecall : [ `Transmit_Channel_OpenConfirmation] = `Transmit_Channel_OpenConfirmation

        method recipient_channel =
          Mpl_uint32.to_int32 (Mpl_uint32.at env (1))
        method set_recipient_channel v : unit =
          Mpl_uint32.marshal (env_at env (1) 4) (Mpl_uint32.of_int32 v)

        method sender_channel =
          Mpl_uint32.to_int32 (Mpl_uint32.at env (1+4))
        method set_sender_channel v : unit =
          Mpl_uint32.marshal (env_at env (1+4) 4) (Mpl_uint32.of_int32 v)

        method initial_window_size =
          Mpl_uint32.to_int32 (Mpl_uint32.at env (1+4+4))
        method set_initial_window_size v : unit =
          Mpl_uint32.marshal (env_at env (1+4+4) 4) (Mpl_uint32.of_int32 v)

        method maximum_packet_size =
          Mpl_uint32.to_int32 (Mpl_uint32.at env (1+4+4+4))
        method set_maximum_packet_size v : unit =
          Mpl_uint32.marshal (env_at env (1+4+4+4) 4) (Mpl_uint32.of_int32 v)


        method prettyprint =
          let out = prerr_endline in
          out "[ Channel.OpenConfirmation.channel ]";
          (* ptype : bound *)
          out ("  recipient_channel = " ^ (Printf.sprintf "%lu" self#recipient_channel));
          out ("  sender_channel = " ^ (Printf.sprintf "%lu" self#sender_channel));
          out ("  initial_window_size = " ^ (Printf.sprintf "%lu" self#initial_window_size));
          out ("  maximum_packet_size = " ^ (Printf.sprintf "%lu" self#maximum_packet_size));
          ()
      end

    let t
      ~recipient_channel
      ~sender_channel
      ~initial_window_size
      ~maximum_packet_size
      env =
        let ptype = (Mpl_byte.of_int 91) in (* const *)
        let recipient_channel = (Mpl_uint32.of_int32 recipient_channel) in
        let sender_channel = (Mpl_uint32.of_int32 sender_channel) in
        let initial_window_size = (Mpl_uint32.of_int32 initial_window_size) in
        let maximum_packet_size = (Mpl_uint32.of_int32 maximum_packet_size) in
        Mpl_byte.marshal env ptype;
        Mpl_uint32.marshal env recipient_channel;
        Mpl_uint32.marshal env sender_channel;
        Mpl_uint32.marshal env initial_window_size;
        Mpl_uint32.marshal env maximum_packet_size;
        new o
        env

    let m (x:(env->o)) env = x env
    let sizeof (x:o) = x#sizeof
    let prettyprint (x:o) = x#prettyprint
    let env (x:o) = x#env
    let recv_statecall = `Receive_Channel_OpenConfirmation
  end

  module Open = struct
    module DirectTCP = struct
      class o
        ~stype
        ~connect_host
        ~origin_address
        (env:env) =
        object(self)
          method env = env_at env 0 self#sizeof
          method sizeof = 4+(Mpl_string32.size origin_address)+4+(Mpl_string32.size connect_host)+4+4+4+(Mpl_string32.size stype)+1
          method xmit_statecall : [ `Transmit_Channel_Open_DirectTCP] = `Transmit_Channel_Open_DirectTCP


          method sender_channel =
            Mpl_uint32.to_int32 (Mpl_uint32.at env (1+(Mpl_string32.size stype)))
          method set_sender_channel v : unit =
            Mpl_uint32.marshal (env_at env (1+(Mpl_string32.size stype)) 4) (Mpl_uint32.of_int32 v)

          method window_size =
            Mpl_uint32.to_int32 (Mpl_uint32.at env (1+(Mpl_string32.size stype)+4))
          method set_window_size v : unit =
            Mpl_uint32.marshal (env_at env (1+(Mpl_string32.size stype)+4) 4) (Mpl_uint32.of_int32 v)

          method max_packet_size =
            Mpl_uint32.to_int32 (Mpl_uint32.at env (1+(Mpl_string32.size stype)+4+4))
          method set_max_packet_size v : unit =
            Mpl_uint32.marshal (env_at env (1+(Mpl_string32.size stype)+4+4) 4) (Mpl_uint32.of_int32 v)

          method connect_host =
            (Mpl_string32.to_string connect_host)
          (* set_connect_host unsupported for now (type custom_type) *)

          method connect_port =
            Mpl_uint32.to_int32 (Mpl_uint32.at env (1+(Mpl_string32.size stype)+4+4+4+(Mpl_string32.size connect_host)))
          method set_connect_port v : unit =
            Mpl_uint32.marshal (env_at env (1+(Mpl_string32.size stype)+4+4+4+(Mpl_string32.size connect_host)) 4) (Mpl_uint32.of_int32 v)

          method origin_address =
            (Mpl_string32.to_string origin_address)
          (* set_origin_address unsupported for now (type custom_type) *)

          method origin_port =
            Mpl_uint32.to_int32 (Mpl_uint32.at env (1+(Mpl_string32.size stype)+4+4+4+(Mpl_string32.size connect_host)+4+(Mpl_string32.size origin_address)))
          method set_origin_port v : unit =
            Mpl_uint32.marshal (env_at env (1+(Mpl_string32.size stype)+4+4+4+(Mpl_string32.size connect_host)+4+(Mpl_string32.size origin_address)) 4) (Mpl_uint32.of_int32 v)


          method prettyprint =
            let out = prerr_endline in
            out "[ Channel.Open.DirectTCP.channel ]";
            (* ptype : bound *)
            (* stype : bound *)
            out ("  sender_channel = " ^ (Printf.sprintf "%lu" self#sender_channel));
            out ("  window_size = " ^ (Printf.sprintf "%lu" self#window_size));
            out ("  max_packet_size = " ^ (Printf.sprintf "%lu" self#max_packet_size));
            out ("  connect_host = " ^ (Mpl_string32.prettyprint self#connect_host));
            out ("  connect_port = " ^ (Printf.sprintf "%lu" self#connect_port));
            out ("  origin_address = " ^ (Mpl_string32.prettyprint self#origin_address));
            out ("  origin_port = " ^ (Printf.sprintf "%lu" self#origin_port));
            ()
        end

      let t
        ~sender_channel
        ~window_size
        ~max_packet_size
        ~connect_host
        ~connect_port
        ~origin_address
        ~origin_port
        env =
          let connect_host = (Mpl_string32.of_string connect_host) in (* custom *)
          let origin_address = (Mpl_string32.of_string origin_address) in (* custom *)
          let ptype = (Mpl_byte.of_int 90) in (* const *)
          let stype = (Mpl_string32.of_string "direct-tcpip") in (* const *)
          let sender_channel = (Mpl_uint32.of_int32 sender_channel) in
          let window_size = (Mpl_uint32.of_int32 window_size) in
          let max_packet_size = (Mpl_uint32.of_int32 max_packet_size) in
          let connect_port = (Mpl_uint32.of_int32 connect_port) in
          let origin_port = (Mpl_uint32.of_int32 origin_port) in
          Mpl_byte.marshal env ptype;
          let stype = Mpl_string32.marshal env stype in
          Mpl_uint32.marshal env sender_channel;
          Mpl_uint32.marshal env window_size;
          Mpl_uint32.marshal env max_packet_size;
          let connect_host = Mpl_string32.marshal env connect_host in
          Mpl_uint32.marshal env connect_port;
          let origin_address = Mpl_string32.marshal env origin_address in
          Mpl_uint32.marshal env origin_port;
          new o
          ~stype:stype
          ~connect_host:connect_host
          ~origin_address:origin_address
          env

      let m (x:(env->o)) env = x env
      let sizeof (x:o) = x#sizeof
      let prettyprint (x:o) = x#prettyprint
      let env (x:o) = x#env
      let recv_statecall = `Receive_Channel_Open_DirectTCP
    end

    module X11 = struct
      class o
        ~stype
        ~origin_address
        (env:env) =
        object(self)
          method env = env_at env 0 self#sizeof
          method sizeof = 4+(Mpl_string32.size origin_address)+4+4+4+(Mpl_string32.size stype)+1
          method xmit_statecall : [ `Transmit_Channel_Open_X11] = `Transmit_Channel_Open_X11


          method sender_channel =
            Mpl_uint32.to_int32 (Mpl_uint32.at env (1+(Mpl_string32.size stype)))
          method set_sender_channel v : unit =
            Mpl_uint32.marshal (env_at env (1+(Mpl_string32.size stype)) 4) (Mpl_uint32.of_int32 v)

          method window_size =
            Mpl_uint32.to_int32 (Mpl_uint32.at env (1+(Mpl_string32.size stype)+4))
          method set_window_size v : unit =
            Mpl_uint32.marshal (env_at env (1+(Mpl_string32.size stype)+4) 4) (Mpl_uint32.of_int32 v)

          method max_packet_size =
            Mpl_uint32.to_int32 (Mpl_uint32.at env (1+(Mpl_string32.size stype)+4+4))
          method set_max_packet_size v : unit =
            Mpl_uint32.marshal (env_at env (1+(Mpl_string32.size stype)+4+4) 4) (Mpl_uint32.of_int32 v)

          method origin_address =
            (Mpl_string32.to_string origin_address)
          (* set_origin_address unsupported for now (type custom_type) *)

          method origin_port =
            Mpl_uint32.to_int32 (Mpl_uint32.at env (1+(Mpl_string32.size stype)+4+4+4+(Mpl_string32.size origin_address)))
          method set_origin_port v : unit =
            Mpl_uint32.marshal (env_at env (1+(Mpl_string32.size stype)+4+4+4+(Mpl_string32.size origin_address)) 4) (Mpl_uint32.of_int32 v)


          method prettyprint =
            let out = prerr_endline in
            out "[ Channel.Open.X11.channel ]";
            (* ptype : bound *)
            (* stype : bound *)
            out ("  sender_channel = " ^ (Printf.sprintf "%lu" self#sender_channel));
            out ("  window_size = " ^ (Printf.sprintf "%lu" self#window_size));
            out ("  max_packet_size = " ^ (Printf.sprintf "%lu" self#max_packet_size));
            out ("  origin_address = " ^ (Mpl_string32.prettyprint self#origin_address));
            out ("  origin_port = " ^ (Printf.sprintf "%lu" self#origin_port));
            ()
        end

      let t
        ~sender_channel
        ~window_size
        ~max_packet_size
        ~origin_address
        ~origin_port
        env =
          let origin_address = (Mpl_string32.of_string origin_address) in (* custom *)
          let ptype = (Mpl_byte.of_int 90) in (* const *)
          let stype = (Mpl_string32.of_string "x11") in (* const *)
          let sender_channel = (Mpl_uint32.of_int32 sender_channel) in
          let window_size = (Mpl_uint32.of_int32 window_size) in
          let max_packet_size = (Mpl_uint32.of_int32 max_packet_size) in
          let origin_port = (Mpl_uint32.of_int32 origin_port) in
          Mpl_byte.marshal env ptype;
          let stype = Mpl_string32.marshal env stype in
          Mpl_uint32.marshal env sender_channel;
          Mpl_uint32.marshal env window_size;
          Mpl_uint32.marshal env max_packet_size;
          let origin_address = Mpl_string32.marshal env origin_address in
          Mpl_uint32.marshal env origin_port;
          new o
          ~stype:stype
          ~origin_address:origin_address
          env

      let m (x:(env->o)) env = x env
      let sizeof (x:o) = x#sizeof
      let prettyprint (x:o) = x#prettyprint
      let env (x:o) = x#env
      let recv_statecall = `Receive_Channel_Open_X11
    end

    module TCPForward = struct
      class o
        ~stype
        ~origin_address
        (env:env) =
        object(self)
          method env = env_at env 0 self#sizeof
          method sizeof = 4+(Mpl_string32.size origin_address)+4+4+4+(Mpl_string32.size stype)+1
          method xmit_statecall : [ `Transmit_Channel_Open_TCPForward] = `Transmit_Channel_Open_TCPForward


          method sender_channel =
            Mpl_uint32.to_int32 (Mpl_uint32.at env (1+(Mpl_string32.size stype)))
          method set_sender_channel v : unit =
            Mpl_uint32.marshal (env_at env (1+(Mpl_string32.size stype)) 4) (Mpl_uint32.of_int32 v)

          method window_size =
            Mpl_uint32.to_int32 (Mpl_uint32.at env (1+(Mpl_string32.size stype)+4))
          method set_window_size v : unit =
            Mpl_uint32.marshal (env_at env (1+(Mpl_string32.size stype)+4) 4) (Mpl_uint32.of_int32 v)

          method max_packet_size =
            Mpl_uint32.to_int32 (Mpl_uint32.at env (1+(Mpl_string32.size stype)+4+4))
          method set_max_packet_size v : unit =
            Mpl_uint32.marshal (env_at env (1+(Mpl_string32.size stype)+4+4) 4) (Mpl_uint32.of_int32 v)

          method origin_address =
            (Mpl_string32.to_string origin_address)
          (* set_origin_address unsupported for now (type custom_type) *)

          method origin_port =
            Mpl_uint32.to_int32 (Mpl_uint32.at env (1+(Mpl_string32.size stype)+4+4+4+(Mpl_string32.size origin_address)))
          method set_origin_port v : unit =
            Mpl_uint32.marshal (env_at env (1+(Mpl_string32.size stype)+4+4+4+(Mpl_string32.size origin_address)) 4) (Mpl_uint32.of_int32 v)


          method prettyprint =
            let out = prerr_endline in
            out "[ Channel.Open.TCPForward.channel ]";
            (* ptype : bound *)
            (* stype : bound *)
            out ("  sender_channel = " ^ (Printf.sprintf "%lu" self#sender_channel));
            out ("  window_size = " ^ (Printf.sprintf "%lu" self#window_size));
            out ("  max_packet_size = " ^ (Printf.sprintf "%lu" self#max_packet_size));
            out ("  origin_address = " ^ (Mpl_string32.prettyprint self#origin_address));
            out ("  origin_port = " ^ (Printf.sprintf "%lu" self#origin_port));
            ()
        end

      let t
        ~sender_channel
        ~window_size
        ~max_packet_size
        ~origin_address
        ~origin_port
        env =
          let origin_address = (Mpl_string32.of_string origin_address) in (* custom *)
          let ptype = (Mpl_byte.of_int 90) in (* const *)
          let stype = (Mpl_string32.of_string "forwarded-tcpip") in (* const *)
          let sender_channel = (Mpl_uint32.of_int32 sender_channel) in
          let window_size = (Mpl_uint32.of_int32 window_size) in
          let max_packet_size = (Mpl_uint32.of_int32 max_packet_size) in
          let origin_port = (Mpl_uint32.of_int32 origin_port) in
          Mpl_byte.marshal env ptype;
          let stype = Mpl_string32.marshal env stype in
          Mpl_uint32.marshal env sender_channel;
          Mpl_uint32.marshal env window_size;
          Mpl_uint32.marshal env max_packet_size;
          let origin_address = Mpl_string32.marshal env origin_address in
          Mpl_uint32.marshal env origin_port;
          new o
          ~stype:stype
          ~origin_address:origin_address
          env

      let m (x:(env->o)) env = x env
      let sizeof (x:o) = x#sizeof
      let prettyprint (x:o) = x#prettyprint
      let env (x:o) = x#env
      let recv_statecall = `Receive_Channel_Open_TCPForward
    end

    module Session = struct
      class o
        ~stype
        (env:env) =
        object(self)
          method env = env_at env 0 self#sizeof
          method sizeof = 4+4+4+(Mpl_string32.size stype)+1
          method xmit_statecall : [ `Transmit_Channel_Open_Session] = `Transmit_Channel_Open_Session


          method sender_channel =
            Mpl_uint32.to_int32 (Mpl_uint32.at env (1+(Mpl_string32.size stype)))
          method set_sender_channel v : unit =
            Mpl_uint32.marshal (env_at env (1+(Mpl_string32.size stype)) 4) (Mpl_uint32.of_int32 v)

          method window_size =
            Mpl_uint32.to_int32 (Mpl_uint32.at env (1+(Mpl_string32.size stype)+4))
          method set_window_size v : unit =
            Mpl_uint32.marshal (env_at env (1+(Mpl_string32.size stype)+4) 4) (Mpl_uint32.of_int32 v)

          method max_packet_size =
            Mpl_uint32.to_int32 (Mpl_uint32.at env (1+(Mpl_string32.size stype)+4+4))
          method set_max_packet_size v : unit =
            Mpl_uint32.marshal (env_at env (1+(Mpl_string32.size stype)+4+4) 4) (Mpl_uint32.of_int32 v)


          method prettyprint =
            let out = prerr_endline in
            out "[ Channel.Open.Session.channel ]";
            (* ptype : bound *)
            (* stype : bound *)
            out ("  sender_channel = " ^ (Printf.sprintf "%lu" self#sender_channel));
            out ("  window_size = " ^ (Printf.sprintf "%lu" self#window_size));
            out ("  max_packet_size = " ^ (Printf.sprintf "%lu" self#max_packet_size));
            ()
        end

      let t
        ~sender_channel
        ~window_size
        ~max_packet_size
        env =
          let ptype = (Mpl_byte.of_int 90) in (* const *)
          let stype = (Mpl_string32.of_string "session") in (* const *)
          let sender_channel = (Mpl_uint32.of_int32 sender_channel) in
          let window_size = (Mpl_uint32.of_int32 window_size) in
          let max_packet_size = (Mpl_uint32.of_int32 max_packet_size) in
          Mpl_byte.marshal env ptype;
          let stype = Mpl_string32.marshal env stype in
          Mpl_uint32.marshal env sender_channel;
          Mpl_uint32.marshal env window_size;
          Mpl_uint32.marshal env max_packet_size;
          new o
          ~stype:stype
          env

      let m (x:(env->o)) env = x env
      let sizeof (x:o) = x#sizeof
      let prettyprint (x:o) = x#prettyprint
      let env (x:o) = x#env
      let recv_statecall = `Receive_Channel_Open_Session
    end

    type o = [
    |`Session of Session.o
    |`TCPForward of TCPForward.o
    |`X11 of X11.o
    |`DirectTCP of DirectTCP.o
    ]

    type x = [
    |`Session of (env -> Session.o)
    |`TCPForward of (env -> TCPForward.o)
    |`X11 of (env -> X11.o)
    |`DirectTCP of (env -> DirectTCP.o)
    ]

    let m (x:x) env : o = match x with
    |`Session (fn:(env->Session.o)) -> `Session (fn env)
    |`TCPForward (fn:(env->TCPForward.o)) -> `TCPForward (fn env)
    |`X11 (fn:(env->X11.o)) -> `X11 (fn env)
    |`DirectTCP (fn:(env->DirectTCP.o)) -> `DirectTCP (fn env)

    let prettyprint (x:o) = match x with
    |`Session x -> x#prettyprint
    |`TCPForward x -> x#prettyprint
    |`X11 x -> x#prettyprint
    |`DirectTCP x -> x#prettyprint

    let sizeof (x:o) = match x with
    |`Session x -> x#sizeof
    |`TCPForward x -> x#sizeof
    |`X11 x -> x#sizeof
    |`DirectTCP x -> x#sizeof

    let env (x:o) = match x with
    |`Session x -> x#env
    |`TCPForward x -> x#env
    |`X11 x -> x#env
    |`DirectTCP x -> x#env

    let recv_statecall (x:o) = match x with
    |`Session x -> Session.recv_statecall 
    |`TCPForward x -> TCPForward.recv_statecall 
    |`X11 x -> X11.recv_statecall 
    |`DirectTCP x -> DirectTCP.recv_statecall 

  end

  module RequestFailure = struct
    class o
      (env:env) =
      object(self)
        method env = env_at env 0 self#sizeof
        method sizeof = 1
        method xmit_statecall : [ `Transmit_Channel_RequestFailure] = `Transmit_Channel_RequestFailure


        method prettyprint =
          let out = prerr_endline in
          out "[ Channel.RequestFailure.channel ]";
          (* ptype : bound *)
          ()
      end

    let t
      env =
        let ptype = (Mpl_byte.of_int 82) in (* const *)
        Mpl_byte.marshal env ptype;
        new o
        env

    let m (x:(env->o)) env = x env
    let sizeof (x:o) = x#sizeof
    let prettyprint (x:o) = x#prettyprint
    let env (x:o) = x#env
    let recv_statecall = `Receive_Channel_RequestFailure
  end

  module RequestSuccessPort = struct
    class o
      (env:env) =
      object(self)
        method env = env_at env 0 self#sizeof
        method sizeof = 4+1
        method xmit_statecall : [ `Transmit_Channel_RequestSuccessPort] = `Transmit_Channel_RequestSuccessPort

        method port =
          Mpl_uint32.to_int32 (Mpl_uint32.at env (1))
        method set_port v : unit =
          Mpl_uint32.marshal (env_at env (1) 4) (Mpl_uint32.of_int32 v)


        method prettyprint =
          let out = prerr_endline in
          out "[ Channel.RequestSuccessPort.channel ]";
          (* ptype : bound *)
          out ("  port = " ^ (Printf.sprintf "%lu" self#port));
          ()
      end

    let t
      ~port
      env =
        let ptype = (Mpl_byte.of_int 81) in (* const *)
        let port = (Mpl_uint32.of_int32 port) in
        Mpl_byte.marshal env ptype;
        Mpl_uint32.marshal env port;
        new o
        env

    let m (x:(env->o)) env = x env
    let sizeof (x:o) = x#sizeof
    let prettyprint (x:o) = x#prettyprint
    let env (x:o) = x#env
    let recv_statecall = `Receive_Channel_RequestSuccessPort
  end

  module RequestSuccess = struct
    class o
      (env:env) =
      object(self)
        method env = env_at env 0 self#sizeof
        method sizeof = 1
        method xmit_statecall : [ `Transmit_Channel_RequestSuccess] = `Transmit_Channel_RequestSuccess


        method prettyprint =
          let out = prerr_endline in
          out "[ Channel.RequestSuccess.channel ]";
          (* ptype : bound *)
          ()
      end

    let t
      env =
        let ptype = (Mpl_byte.of_int 81) in (* const *)
        Mpl_byte.marshal env ptype;
        new o
        env

    let m (x:(env->o)) env = x env
    let sizeof (x:o) = x#sizeof
    let prettyprint (x:o) = x#prettyprint
    let env (x:o) = x#env
    let recv_statecall = `Receive_Channel_RequestSuccess
  end

  module GlobalRequest = struct
    module CancelTCPForward = struct
      class o
        ~reqtype
        ~want_reply
        ~bind_address
        (env:env) =
        object(self)
          method env = env_at env 0 self#sizeof
          method sizeof = 4+(Mpl_string32.size bind_address)+1+(Mpl_string32.size reqtype)+1
          method xmit_statecall : [ `Transmit_Channel_GlobalRequest_CancelTCPForward] = `Transmit_Channel_GlobalRequest_CancelTCPForward


          method want_reply =
            (Mpl_boolean.to_bool want_reply)
          (* set_want_reply unsupported for now (type custom_type) *)

          method bind_address =
            (Mpl_string32.to_string bind_address)
          (* set_bind_address unsupported for now (type custom_type) *)

          method port =
            Mpl_uint32.to_int32 (Mpl_uint32.at env (1+(Mpl_string32.size reqtype)+1+(Mpl_string32.size bind_address)))
          method set_port v : unit =
            Mpl_uint32.marshal (env_at env (1+(Mpl_string32.size reqtype)+1+(Mpl_string32.size bind_address)) 4) (Mpl_uint32.of_int32 v)


          method prettyprint =
            let out = prerr_endline in
            out "[ Channel.GlobalRequest.CancelTCPForward.channel ]";
            (* ptype : bound *)
            (* reqtype : bound *)
            out ("  want_reply = " ^ (Mpl_boolean.prettyprint self#want_reply));
            out ("  bind_address = " ^ (Mpl_string32.prettyprint self#bind_address));
            out ("  port = " ^ (Printf.sprintf "%lu" self#port));
            ()
        end

      let t
        ~want_reply
        ~bind_address
        ~port
        env =
          let want_reply = (Mpl_boolean.of_bool want_reply) in (* custom *)
          let bind_address = (Mpl_string32.of_string bind_address) in (* custom *)
          let ptype = (Mpl_byte.of_int 80) in (* const *)
          let reqtype = (Mpl_string32.of_string "cancel-tcpip-forward") in (* const *)
          let port = (Mpl_uint32.of_int32 port) in
          Mpl_byte.marshal env ptype;
          let reqtype = Mpl_string32.marshal env reqtype in
          let want_reply = Mpl_boolean.marshal env want_reply in
          let bind_address = Mpl_string32.marshal env bind_address in
          Mpl_uint32.marshal env port;
          new o
          ~reqtype:reqtype
          ~want_reply:want_reply
          ~bind_address:bind_address
          env

      let m (x:(env->o)) env = x env
      let sizeof (x:o) = x#sizeof
      let prettyprint (x:o) = x#prettyprint
      let env (x:o) = x#env
      let recv_statecall = `Receive_Channel_GlobalRequest_CancelTCPForward
    end

    module TCPForward = struct
      class o
        ~reqtype
        ~want_reply
        ~bind_address
        (env:env) =
        object(self)
          method env = env_at env 0 self#sizeof
          method sizeof = 4+(Mpl_string32.size bind_address)+1+(Mpl_string32.size reqtype)+1
          method xmit_statecall : [ `Transmit_Channel_GlobalRequest_TCPForward] = `Transmit_Channel_GlobalRequest_TCPForward


          method want_reply =
            (Mpl_boolean.to_bool want_reply)
          (* set_want_reply unsupported for now (type custom_type) *)

          method bind_address =
            (Mpl_string32.to_string bind_address)
          (* set_bind_address unsupported for now (type custom_type) *)

          method port =
            Mpl_uint32.to_int32 (Mpl_uint32.at env (1+(Mpl_string32.size reqtype)+1+(Mpl_string32.size bind_address)))
          method set_port v : unit =
            Mpl_uint32.marshal (env_at env (1+(Mpl_string32.size reqtype)+1+(Mpl_string32.size bind_address)) 4) (Mpl_uint32.of_int32 v)


          method prettyprint =
            let out = prerr_endline in
            out "[ Channel.GlobalRequest.TCPForward.channel ]";
            (* ptype : bound *)
            (* reqtype : bound *)
            out ("  want_reply = " ^ (Mpl_boolean.prettyprint self#want_reply));
            out ("  bind_address = " ^ (Mpl_string32.prettyprint self#bind_address));
            out ("  port = " ^ (Printf.sprintf "%lu" self#port));
            ()
        end

      let t
        ~want_reply
        ~bind_address
        ~port
        env =
          let want_reply = (Mpl_boolean.of_bool want_reply) in (* custom *)
          let bind_address = (Mpl_string32.of_string bind_address) in (* custom *)
          let ptype = (Mpl_byte.of_int 80) in (* const *)
          let reqtype = (Mpl_string32.of_string "tcpip-forward") in (* const *)
          let port = (Mpl_uint32.of_int32 port) in
          Mpl_byte.marshal env ptype;
          let reqtype = Mpl_string32.marshal env reqtype in
          let want_reply = Mpl_boolean.marshal env want_reply in
          let bind_address = Mpl_string32.marshal env bind_address in
          Mpl_uint32.marshal env port;
          new o
          ~reqtype:reqtype
          ~want_reply:want_reply
          ~bind_address:bind_address
          env

      let m (x:(env->o)) env = x env
      let sizeof (x:o) = x#sizeof
      let prettyprint (x:o) = x#prettyprint
      let env (x:o) = x#env
      let recv_statecall = `Receive_Channel_GlobalRequest_TCPForward
    end

    type o = [
    |`TCPForward of TCPForward.o
    |`CancelTCPForward of CancelTCPForward.o
    ]

    type x = [
    |`TCPForward of (env -> TCPForward.o)
    |`CancelTCPForward of (env -> CancelTCPForward.o)
    ]

    let m (x:x) env : o = match x with
    |`TCPForward (fn:(env->TCPForward.o)) -> `TCPForward (fn env)
    |`CancelTCPForward (fn:(env->CancelTCPForward.o)) -> `CancelTCPForward (fn env)

    let prettyprint (x:o) = match x with
    |`TCPForward x -> x#prettyprint
    |`CancelTCPForward x -> x#prettyprint

    let sizeof (x:o) = match x with
    |`TCPForward x -> x#sizeof
    |`CancelTCPForward x -> x#sizeof

    let env (x:o) = match x with
    |`TCPForward x -> x#env
    |`CancelTCPForward x -> x#env

    let recv_statecall (x:o) = match x with
    |`TCPForward x -> TCPForward.recv_statecall 
    |`CancelTCPForward x -> CancelTCPForward.recv_statecall 

  end

  type o = [
  |`GlobalRequest of GlobalRequest.o
  |`RequestSuccess of RequestSuccess.o
  |`RequestSuccessPort of RequestSuccessPort.o
  |`RequestFailure of RequestFailure.o
  |`Open of Open.o
  |`OpenConfirmation of OpenConfirmation.o
  |`OpenFailure of OpenFailure.o
  |`WindowAdjust of WindowAdjust.o
  |`Data of Data.o
  |`ExtendedData of ExtendedData.o
  |`EOF of EOF.o
  |`Close of Close.o
  |`Request of Request.o
  |`Success of Success.o
  |`Failure of Failure.o
  ]

  type x = [
  |`GlobalRequest of (env -> GlobalRequest.o)
  |`RequestSuccess of (env -> RequestSuccess.o)
  |`RequestSuccessPort of (env -> RequestSuccessPort.o)
  |`RequestFailure of (env -> RequestFailure.o)
  |`Open of (env -> Open.o)
  |`OpenConfirmation of (env -> OpenConfirmation.o)
  |`OpenFailure of (env -> OpenFailure.o)
  |`WindowAdjust of (env -> WindowAdjust.o)
  |`Data of (env -> Data.o)
  |`ExtendedData of (env -> ExtendedData.o)
  |`EOF of (env -> EOF.o)
  |`Close of (env -> Close.o)
  |`Request of (env -> Request.o)
  |`Success of (env -> Success.o)
  |`Failure of (env -> Failure.o)
  ]

  let m (x:x) env : o = match x with
  |`GlobalRequest (fn:(env->GlobalRequest.o)) -> `GlobalRequest (fn env)
  |`RequestSuccess (fn:(env->RequestSuccess.o)) -> `RequestSuccess (fn env)
  |`RequestSuccessPort (fn:(env->RequestSuccessPort.o)) -> `RequestSuccessPort (fn env)
  |`RequestFailure (fn:(env->RequestFailure.o)) -> `RequestFailure (fn env)
  |`Open (fn:(env->Open.o)) -> `Open (fn env)
  |`OpenConfirmation (fn:(env->OpenConfirmation.o)) -> `OpenConfirmation (fn env)
  |`OpenFailure (fn:(env->OpenFailure.o)) -> `OpenFailure (fn env)
  |`WindowAdjust (fn:(env->WindowAdjust.o)) -> `WindowAdjust (fn env)
  |`Data (fn:(env->Data.o)) -> `Data (fn env)
  |`ExtendedData (fn:(env->ExtendedData.o)) -> `ExtendedData (fn env)
  |`EOF (fn:(env->EOF.o)) -> `EOF (fn env)
  |`Close (fn:(env->Close.o)) -> `Close (fn env)
  |`Request (fn:(env->Request.o)) -> `Request (fn env)
  |`Success (fn:(env->Success.o)) -> `Success (fn env)
  |`Failure (fn:(env->Failure.o)) -> `Failure (fn env)

  let prettyprint (x:o) = match x with
  |`GlobalRequest x -> GlobalRequest.prettyprint x
  |`RequestSuccess x -> x#prettyprint
  |`RequestSuccessPort x -> x#prettyprint
  |`RequestFailure x -> x#prettyprint
  |`Open x -> Open.prettyprint x
  |`OpenConfirmation x -> x#prettyprint
  |`OpenFailure x -> x#prettyprint
  |`WindowAdjust x -> x#prettyprint
  |`Data x -> x#prettyprint
  |`ExtendedData x -> x#prettyprint
  |`EOF x -> x#prettyprint
  |`Close x -> x#prettyprint
  |`Request x -> Request.prettyprint x
  |`Success x -> x#prettyprint
  |`Failure x -> x#prettyprint

  let sizeof (x:o) = match x with
  |`GlobalRequest x -> GlobalRequest.sizeof x
  |`RequestSuccess x -> x#sizeof
  |`RequestSuccessPort x -> x#sizeof
  |`RequestFailure x -> x#sizeof
  |`Open x -> Open.sizeof x
  |`OpenConfirmation x -> x#sizeof
  |`OpenFailure x -> x#sizeof
  |`WindowAdjust x -> x#sizeof
  |`Data x -> x#sizeof
  |`ExtendedData x -> x#sizeof
  |`EOF x -> x#sizeof
  |`Close x -> x#sizeof
  |`Request x -> Request.sizeof x
  |`Success x -> x#sizeof
  |`Failure x -> x#sizeof

  let env (x:o) = match x with
  |`GlobalRequest x -> GlobalRequest.env x
  |`RequestSuccess x -> x#env
  |`RequestSuccessPort x -> x#env
  |`RequestFailure x -> x#env
  |`Open x -> Open.env x
  |`OpenConfirmation x -> x#env
  |`OpenFailure x -> x#env
  |`WindowAdjust x -> x#env
  |`Data x -> x#env
  |`ExtendedData x -> x#env
  |`EOF x -> x#env
  |`Close x -> x#env
  |`Request x -> Request.env x
  |`Success x -> x#env
  |`Failure x -> x#env

  let recv_statecall (x:o) = match x with
  |`GlobalRequest x -> GlobalRequest.recv_statecall x
  |`RequestSuccess x -> RequestSuccess.recv_statecall 
  |`RequestSuccessPort x -> RequestSuccessPort.recv_statecall 
  |`RequestFailure x -> RequestFailure.recv_statecall 
  |`Open x -> Open.recv_statecall x
  |`OpenConfirmation x -> OpenConfirmation.recv_statecall 
  |`OpenFailure x -> OpenFailure.recv_statecall 
  |`WindowAdjust x -> WindowAdjust.recv_statecall 
  |`Data x -> Data.recv_statecall 
  |`ExtendedData x -> ExtendedData.recv_statecall 
  |`EOF x -> EOF.recv_statecall 
  |`Close x -> Close.recv_statecall 
  |`Request x -> Request.recv_statecall x
  |`Success x -> Success.recv_statecall 
  |`Failure x -> Failure.recv_statecall 


  let unmarshal 
    ~(expecting_port:bool)
    (env:env) : o =
    let ptype = Mpl_byte.to_int (Mpl_byte.unmarshal env) in
    match ptype with
    |100 -> `Failure (
      skip env 4; (* skipped recipient_channel *)
      new Failure.o env
    )
    |99 -> `Success (
      skip env 4; (* skipped recipient_channel *)
      new Success.o env
    )
    |98 -> `Request (
      skip env 4; (* skipped recipient_channel *)
      let reqtype = Mpl_string32.unmarshal env in
      match (Mpl_string32.to_string reqtype) with
      |"exit-signal" -> `ExitSignal (
        let reserved = Mpl_boolean.unmarshal env in (* custom *)
        let signal = Mpl_string32.unmarshal env in (* custom *)
        let core_dumped = Mpl_boolean.unmarshal env in (* custom *)
        let error = Mpl_string32.unmarshal env in (* custom *)
        let language = Mpl_string32.unmarshal env in (* custom *)
        new Request.ExitSignal.o env
        ~reqtype:reqtype
        ~signal:signal
        ~core_dumped:core_dumped
        ~error:error
        ~language:language
      )
      |"exit-status" -> `ExitStatus (
        let reserved = Mpl_boolean.unmarshal env in (* custom *)
        skip env 4; (* skipped exit_status *)
        new Request.ExitStatus.o env
        ~reqtype:reqtype
      )
      |"signal" -> `Signal (
        let reserved = Mpl_boolean.unmarshal env in (* custom *)
        let signal = Mpl_string32.unmarshal env in (* custom *)
        new Request.Signal.o env
        ~reqtype:reqtype
        ~signal:signal
      )
      |"xon-xoff" -> `LocalFlowControl (
        let reserved = Mpl_boolean.unmarshal env in (* custom *)
        let can_do = Mpl_boolean.unmarshal env in (* custom *)
        new Request.LocalFlowControl.o env
        ~reqtype:reqtype
        ~can_do:can_do
      )
      |"window-change" -> `WindowChange (
        let reserved = Mpl_boolean.unmarshal env in (* custom *)
        skip env 4; (* skipped col *)
        skip env 4; (* skipped row *)
        skip env 4; (* skipped xpixel *)
        skip env 4; (* skipped ypixel *)
        new Request.WindowChange.o env
        ~reqtype:reqtype
      )
      |"subsystem" -> `Subsystem (
        let want_reply = Mpl_boolean.unmarshal env in (* custom *)
        let subsystem = Mpl_string32.unmarshal env in (* custom *)
        new Request.Subsystem.o env
        ~reqtype:reqtype
        ~want_reply:want_reply
        ~subsystem:subsystem
      )
      |"exec" -> `Exec (
        let want_reply = Mpl_boolean.unmarshal env in (* custom *)
        let command = Mpl_string32.unmarshal env in (* custom *)
        new Request.Exec.o env
        ~reqtype:reqtype
        ~want_reply:want_reply
        ~command:command
      )
      |"env" -> `Env (
        let want_reply = Mpl_boolean.unmarshal env in (* custom *)
        let name = Mpl_string32.unmarshal env in (* custom *)
        let value = Mpl_string32.unmarshal env in (* custom *)
        new Request.Env.o env
        ~reqtype:reqtype
        ~want_reply:want_reply
        ~name:name
        ~value:value
      )
      |"shell" -> `Shell (
        let want_reply = Mpl_boolean.unmarshal env in (* custom *)
        new Request.Shell.o env
        ~reqtype:reqtype
        ~want_reply:want_reply
      )
      |"x11-req" -> `X11 (
        let auth_cookie = Mpl_string32.unmarshal env in (* custom *)
        skip env 4; (* skipped screen *)
        new Request.X11.o env
        ~reqtype:reqtype
        ~auth_cookie:auth_cookie
      )
      |"pty-req" -> `Pty (
        let want_reply = Mpl_boolean.unmarshal env in (* custom *)
        let term = Mpl_string32.unmarshal env in (* custom *)
        skip env 4; (* skipped width_chars *)
        skip env 4; (* skipped height_rows *)
        skip env 4; (* skipped width_pixels *)
        skip env 4; (* skipped height_pixels *)
        new Request.Pty.o env
        ~reqtype:reqtype
        ~want_reply:want_reply
        ~term:term
      )
      |x -> raise (Bad_packet (Printf.sprintf "Request: %S" x))
    )
    |97 -> `Close (
      skip env 4; (* skipped recipient_channel *)
      new Close.o env
    )
    |96 -> `EOF (
      skip env 4; (* skipped recipient_channel *)
      new EOF.o env
    )
    |95 -> `ExtendedData (
      skip env 4; (* skipped recipient_channel *)
      skip env 4; (* skipped data_type *)
      let datalen = Mpl_uint32.unmarshal env in
      let data_length = (Mpl_uint32.to_int datalen) in
      skip env data_length; (* skipped data *)
      new ExtendedData.o env
      ~data_length:data_length
    )
    |94 -> `Data (
      skip env 4; (* skipped recipient_channel *)
      let datalen = Mpl_uint32.unmarshal env in
      let data_length = (Mpl_uint32.to_int datalen) in
      skip env data_length; (* skipped data *)
      new Data.o env
      ~data_length:data_length
    )
    |93 -> `WindowAdjust (
      skip env 4; (* skipped recipient_channel *)
      skip env 4; (* skipped bytes_to_add *)
      new WindowAdjust.o env
    )
    |92 -> `OpenFailure (
      skip env 4; (* skipped recipient_channel *)
      skip env 4; (* skipped reason_code *)
      let information = Mpl_string32.unmarshal env in (* custom *)
      let language = Mpl_string32.unmarshal env in (* custom *)
      new OpenFailure.o env
      ~information:information
      ~language:language
    )
    |91 -> `OpenConfirmation (
      skip env 4; (* skipped recipient_channel *)
      skip env 4; (* skipped sender_channel *)
      skip env 4; (* skipped initial_window_size *)
      skip env 4; (* skipped maximum_packet_size *)
      new OpenConfirmation.o env
    )
    |90 -> `Open (
      let stype = Mpl_string32.unmarshal env in
      match (Mpl_string32.to_string stype) with
      |"direct-tcpip" -> `DirectTCP (
        skip env 4; (* skipped sender_channel *)
        skip env 4; (* skipped window_size *)
        skip env 4; (* skipped max_packet_size *)
        let connect_host = Mpl_string32.unmarshal env in (* custom *)
        skip env 4; (* skipped connect_port *)
        let origin_address = Mpl_string32.unmarshal env in (* custom *)
        skip env 4; (* skipped origin_port *)
        new Open.DirectTCP.o env
        ~stype:stype
        ~connect_host:connect_host
        ~origin_address:origin_address
      )
      |"x11" -> `X11 (
        skip env 4; (* skipped sender_channel *)
        skip env 4; (* skipped window_size *)
        skip env 4; (* skipped max_packet_size *)
        let origin_address = Mpl_string32.unmarshal env in (* custom *)
        skip env 4; (* skipped origin_port *)
        new Open.X11.o env
        ~stype:stype
        ~origin_address:origin_address
      )
      |"forwarded-tcpip" -> `TCPForward (
        skip env 4; (* skipped sender_channel *)
        skip env 4; (* skipped window_size *)
        skip env 4; (* skipped max_packet_size *)
        let origin_address = Mpl_string32.unmarshal env in (* custom *)
        skip env 4; (* skipped origin_port *)
        new Open.TCPForward.o env
        ~stype:stype
        ~origin_address:origin_address
      )
      |"session" -> `Session (
        skip env 4; (* skipped sender_channel *)
        skip env 4; (* skipped window_size *)
        skip env 4; (* skipped max_packet_size *)
        new Open.Session.o env
        ~stype:stype
      )
      |x -> raise (Bad_packet (Printf.sprintf "Open: %S" x))
    )
    |82 -> `RequestFailure (
      new RequestFailure.o env
    )
    |81 when (expecting_port) -> `RequestSuccessPort (
      skip env 4; (* skipped port *)
      new RequestSuccessPort.o env
    )
    |81 when ((not expecting_port)) -> `RequestSuccess (
      new RequestSuccess.o env
    )
    |80 -> `GlobalRequest (
      let reqtype = Mpl_string32.unmarshal env in
      let want_reply = Mpl_boolean.unmarshal env in (* custom *)
      let bind_address = Mpl_string32.unmarshal env in (* custom *)
      skip env 4; (* skipped port *)
      match (Mpl_string32.to_string reqtype) with
      |"cancel-tcpip-forward" -> `CancelTCPForward (
        new GlobalRequest.CancelTCPForward.o env
        ~reqtype:reqtype
        ~want_reply:want_reply
        ~bind_address:bind_address
      )
      |"tcpip-forward" -> `TCPForward (
        new GlobalRequest.TCPForward.o env
        ~reqtype:reqtype
        ~want_reply:want_reply
        ~bind_address:bind_address
      )
      |x -> raise (Bad_packet (Printf.sprintf "GlobalRequest: %S" x))
    )
    |x -> raise (Bad_packet (Printf.sprintf ": %d" x))
end

module Ssh = struct
  open Mpl_stdlib
  exception Bad_packet of string

  type statecalls = [
    |`Transmit_Ssh |`Receive_Ssh
  ]

  class o
    ~(data_length:int)
    ~(padding_length:int)
    (env:env) =
    object(self)
      method env = env_at env 0 self#sizeof
      method sizeof = padding_length+data_length+1+4
      method xmit_statecall : [ `Transmit_Ssh] = `Transmit_Ssh


      method data =
        Mpl_raw.at env (4+1) data_length
      (* set_data unsupported for now (type byte array) *)
      method data_env : env = env_at env (4+1) data_length
      method data_frag = Mpl_raw.frag env (4+1) data_length
      method data_length = data_length

      method padding =
        Mpl_raw.at env (4+1+data_length) padding_length
      (* set_padding unsupported for now (type byte array) *)
      method padding_env : env = env_at env (4+1+data_length) padding_length
      method padding_frag = Mpl_raw.frag env (4+1+data_length) padding_length
      method padding_length = padding_length

      method mac_start = 4+1+data_length+padding_length


      method prettyprint =
        let out = prerr_endline in
        out "[ Ssh.ssh ]";
        (* packet_len : bound *)
        (* padding_len : bound *)
        out ("  data = " ^ (Mpl_raw.prettyprint self#data));
        out ("  padding = " ^ (Mpl_raw.prettyprint self#padding));
        (* mac_start : bound *)
        ()
    end

  let t
    ~(data:data)
    ~(padding:data)
    env =
      let packet_len___offset = 4 in
      let ___env = env_at env (4+1) 0 in
      let data___len = match data with 
      |`Str x -> Mpl_raw.marshal ___env x; String.length x
      |`Sub fn -> fn ___env; curpos ___env
      |`None -> 0
      |`Frag t -> Mpl_raw.blit ___env t; curpos ___env in
      let ___env = env_at env (4+1+data___len) 0 in
      let padding___len = match padding with 
      |`Str x -> Mpl_raw.marshal ___env x; String.length x
      |`Sub fn -> fn ___env; curpos ___env
      |`None -> 0
      |`Frag t -> Mpl_raw.blit ___env t; curpos ___env in
      let padding___offset = 4+1+data___len+padding___len in
      let padding___sizeof = padding___len in
      let packet_len = (Mpl_uint32.of_int32 (Int32.sub (Int32.of_int padding___offset) (Int32.of_int packet_len___offset))) in (* bound *)
      let padding_len = (Mpl_byte.of_int padding___sizeof) in (* bound *)
      let data = data in
      let padding = padding in
      Mpl_uint32.marshal env packet_len;
      Mpl_byte.marshal env padding_len;
      skip env data___len;
      skip env padding___len;
      new o
      ~data_length:data___len
      ~padding_length:padding___len
      env

  let m (x:(env->o)) env = x env
  let sizeof (x:o) = x#sizeof
  let prettyprint (x:o) = x#prettyprint
  let env (x:o) = x#env
  let recv_statecall = `Receive_Ssh

  let unmarshal 
    (env:env) : o =
    let packet_len = Mpl_uint32.unmarshal env in
    let packet_len___offset = curpos env in
    let padding_len = Mpl_byte.to_int (Mpl_byte.unmarshal env) in
    let data_length = (((Mpl_uint32.to_int packet_len) - padding_len) - 1) in
    skip env data_length; (* skipped data *)
    let padding_length = padding_len in
    skip env padding_length; (* skipped padding *)
    let padding___offset = curpos env in
    skip env 0; (* skipped mac_start *)
    new o env
    ~data_length:data_length
    ~padding_length:padding_length
end

module Key = struct
  open Mpl_stdlib
  exception Bad_packet of string

  type statecalls = [
    |`Transmit_Key_DSS |`Receive_Key_DSS
    |`Transmit_Key_RSA |`Receive_Key_RSA
  ]

  module RSA = struct
    class o
      ~name
      ~e
      ~n
      (env:env) =
      object(self)
        method env = env_at env 0 self#sizeof
        method sizeof = (Mpl_mpint.size n)+(Mpl_mpint.size e)+(Mpl_string32.size name)
        method xmit_statecall : [ `Transmit_Key_RSA] = `Transmit_Key_RSA

        method e =
          (e)
        (* set_e unsupported for now (type custom_type) *)

        method n =
          (n)
        (* set_n unsupported for now (type custom_type) *)


        method prettyprint =
          let out = prerr_endline in
          out "[ Key.RSA.key ]";
          (* name : bound *)
          out ("  e = " ^ (Mpl_mpint.prettyprint self#e));
          out ("  n = " ^ (Mpl_mpint.prettyprint self#n));
          ()
      end

    let t
      ~e
      ~n
      env =
        let e = (e) in (* custom *)
        let n = (n) in (* custom *)
        let name = (Mpl_string32.of_string "ssh-rsa") in (* const *)
        let name = Mpl_string32.marshal env name in
        let e = Mpl_mpint.marshal env e in
        let n = Mpl_mpint.marshal env n in
        new o
        ~name:name
        ~e:e
        ~n:n
        env

    let m (x:(env->o)) env = x env
    let sizeof (x:o) = x#sizeof
    let prettyprint (x:o) = x#prettyprint
    let env (x:o) = x#env
    let recv_statecall = `Receive_Key_RSA
  end

  module DSS = struct
    class o
      ~name
      ~p
      ~q
      ~g
      ~y
      (env:env) =
      object(self)
        method env = env_at env 0 self#sizeof
        method sizeof = (Mpl_mpint.size y)+(Mpl_mpint.size g)+(Mpl_mpint.size q)+(Mpl_mpint.size p)+(Mpl_string32.size name)
        method xmit_statecall : [ `Transmit_Key_DSS] = `Transmit_Key_DSS

        method p =
          (p)
        (* set_p unsupported for now (type custom_type) *)

        method q =
          (q)
        (* set_q unsupported for now (type custom_type) *)

        method g =
          (g)
        (* set_g unsupported for now (type custom_type) *)

        method y =
          (y)
        (* set_y unsupported for now (type custom_type) *)


        method prettyprint =
          let out = prerr_endline in
          out "[ Key.DSS.key ]";
          (* name : bound *)
          out ("  p = " ^ (Mpl_mpint.prettyprint self#p));
          out ("  q = " ^ (Mpl_mpint.prettyprint self#q));
          out ("  g = " ^ (Mpl_mpint.prettyprint self#g));
          out ("  y = " ^ (Mpl_mpint.prettyprint self#y));
          ()
      end

    let t
      ~p
      ~q
      ~g
      ~y
      env =
        let p = (p) in (* custom *)
        let q = (q) in (* custom *)
        let g = (g) in (* custom *)
        let y = (y) in (* custom *)
        let name = (Mpl_string32.of_string "ssh-dss") in (* const *)
        let name = Mpl_string32.marshal env name in
        let p = Mpl_mpint.marshal env p in
        let q = Mpl_mpint.marshal env q in
        let g = Mpl_mpint.marshal env g in
        let y = Mpl_mpint.marshal env y in
        new o
        ~name:name
        ~p:p
        ~q:q
        ~g:g
        ~y:y
        env

    let m (x:(env->o)) env = x env
    let sizeof (x:o) = x#sizeof
    let prettyprint (x:o) = x#prettyprint
    let env (x:o) = x#env
    let recv_statecall = `Receive_Key_DSS
  end

  type o = [
  |`DSS of DSS.o
  |`RSA of RSA.o
  ]

  type x = [
  |`DSS of (env -> DSS.o)
  |`RSA of (env -> RSA.o)
  ]

  let m (x:x) env : o = match x with
  |`DSS (fn:(env->DSS.o)) -> `DSS (fn env)
  |`RSA (fn:(env->RSA.o)) -> `RSA (fn env)

  let prettyprint (x:o) = match x with
  |`DSS x -> x#prettyprint
  |`RSA x -> x#prettyprint

  let sizeof (x:o) = match x with
  |`DSS x -> x#sizeof
  |`RSA x -> x#sizeof

  let env (x:o) = match x with
  |`DSS x -> x#env
  |`RSA x -> x#env

  let recv_statecall (x:o) = match x with
  |`DSS x -> DSS.recv_statecall 
  |`RSA x -> RSA.recv_statecall 


  let unmarshal 
    (env:env) : o =
    let name = Mpl_string32.unmarshal env in
    match (Mpl_string32.to_string name) with
    |"ssh-rsa" -> `RSA (
      let e = Mpl_mpint.unmarshal env in (* custom *)
      let n = Mpl_mpint.unmarshal env in (* custom *)
      new RSA.o env
      ~name:name
      ~e:e
      ~n:n
    )
    |"ssh-dss" -> `DSS (
      let p = Mpl_mpint.unmarshal env in (* custom *)
      let q = Mpl_mpint.unmarshal env in (* custom *)
      let g = Mpl_mpint.unmarshal env in (* custom *)
      let y = Mpl_mpint.unmarshal env in (* custom *)
      new DSS.o env
      ~name:name
      ~p:p
      ~q:q
      ~g:g
      ~y:y
    )
    |x -> raise (Bad_packet (Printf.sprintf ": %S" x))
end

module Sig = struct
  open Mpl_stdlib
  exception Bad_packet of string

  type statecalls = [
    |`Transmit_Sig_DSS |`Receive_Sig_DSS
    |`Transmit_Sig_RSA |`Receive_Sig_RSA
  ]

  module RSA = struct
    class o
      ~name
      ~sig_blob
      (env:env) =
      object(self)
        method env = env_at env 0 self#sizeof
        method sizeof = (Mpl_string32.size sig_blob)+(Mpl_string32.size name)
        method xmit_statecall : [ `Transmit_Sig_RSA] = `Transmit_Sig_RSA

        method sig_blob =
          (Mpl_string32.to_string sig_blob)
        (* set_sig_blob unsupported for now (type custom_type) *)


        method prettyprint =
          let out = prerr_endline in
          out "[ Sig.RSA.sig ]";
          (* name : bound *)
          out ("  sig_blob = " ^ (Mpl_string32.prettyprint self#sig_blob));
          ()
      end

    let t
      ~sig_blob
      env =
        let sig_blob = (Mpl_string32.of_string sig_blob) in (* custom *)
        let name = (Mpl_string32.of_string "ssh-rsa") in (* const *)
        let name = Mpl_string32.marshal env name in
        let sig_blob = Mpl_string32.marshal env sig_blob in
        new o
        ~name:name
        ~sig_blob:sig_blob
        env

    let m (x:(env->o)) env = x env
    let sizeof (x:o) = x#sizeof
    let prettyprint (x:o) = x#prettyprint
    let env (x:o) = x#env
    let recv_statecall = `Receive_Sig_RSA
  end

  module DSS = struct
    class o
      ~name
      ~sig_blob
      (env:env) =
      object(self)
        method env = env_at env 0 self#sizeof
        method sizeof = (Mpl_string32.size sig_blob)+(Mpl_string32.size name)
        method xmit_statecall : [ `Transmit_Sig_DSS] = `Transmit_Sig_DSS

        method sig_blob =
          (Mpl_string32.to_string sig_blob)
        (* set_sig_blob unsupported for now (type custom_type) *)


        method prettyprint =
          let out = prerr_endline in
          out "[ Sig.DSS.sig ]";
          (* name : bound *)
          out ("  sig_blob = " ^ (Mpl_string32.prettyprint self#sig_blob));
          ()
      end

    let t
      ~sig_blob
      env =
        let sig_blob = (Mpl_string32.of_string sig_blob) in (* custom *)
        let name = (Mpl_string32.of_string "ssh-dss") in (* const *)
        let name = Mpl_string32.marshal env name in
        let sig_blob = Mpl_string32.marshal env sig_blob in
        new o
        ~name:name
        ~sig_blob:sig_blob
        env

    let m (x:(env->o)) env = x env
    let sizeof (x:o) = x#sizeof
    let prettyprint (x:o) = x#prettyprint
    let env (x:o) = x#env
    let recv_statecall = `Receive_Sig_DSS
  end

  type o = [
  |`DSS of DSS.o
  |`RSA of RSA.o
  ]

  type x = [
  |`DSS of (env -> DSS.o)
  |`RSA of (env -> RSA.o)
  ]

  let m (x:x) env : o = match x with
  |`DSS (fn:(env->DSS.o)) -> `DSS (fn env)
  |`RSA (fn:(env->RSA.o)) -> `RSA (fn env)

  let prettyprint (x:o) = match x with
  |`DSS x -> x#prettyprint
  |`RSA x -> x#prettyprint

  let sizeof (x:o) = match x with
  |`DSS x -> x#sizeof
  |`RSA x -> x#sizeof

  let env (x:o) = match x with
  |`DSS x -> x#env
  |`RSA x -> x#env

  let recv_statecall (x:o) = match x with
  |`DSS x -> DSS.recv_statecall 
  |`RSA x -> RSA.recv_statecall 


  let unmarshal 
    (env:env) : o =
    let name = Mpl_string32.unmarshal env in
    let sig_blob = Mpl_string32.unmarshal env in (* custom *)
    match (Mpl_string32.to_string name) with
    |"ssh-rsa" -> `RSA (
      new RSA.o env
      ~name:name
      ~sig_blob:sig_blob
    )
    |"ssh-dss" -> `DSS (
      new DSS.o env
      ~name:name
      ~sig_blob:sig_blob
    )
    |x -> raise (Bad_packet (Printf.sprintf ": %S" x))
end

module Kex_hash = struct
  open Mpl_stdlib
  exception Bad_packet of string

  type statecalls = [
    |`Transmit_Kex_hash |`Receive_Kex_hash
  ]

  class o
    ~v_c
    ~v_s
    ~i_c
    ~i_s
    ~k_s
    ~e
    ~f
    ~k
    (env:env) =
    object(self)
      method env = env_at env 0 self#sizeof
      method sizeof = (Mpl_mpint.size k)+(Mpl_mpint.size f)+(Mpl_mpint.size e)+(Mpl_string32.size k_s)+(Mpl_string32.size i_s)+(Mpl_string32.size i_c)+(Mpl_string32.size v_s)+(Mpl_string32.size v_c)
      method xmit_statecall : [ `Transmit_Kex_hash] = `Transmit_Kex_hash
      method v_c =
        (Mpl_string32.to_string v_c)
      (* set_v_c unsupported for now (type custom_type) *)

      method v_s =
        (Mpl_string32.to_string v_s)
      (* set_v_s unsupported for now (type custom_type) *)

      method i_c =
        (Mpl_string32.to_string i_c)
      (* set_i_c unsupported for now (type custom_type) *)

      method i_s =
        (Mpl_string32.to_string i_s)
      (* set_i_s unsupported for now (type custom_type) *)

      method k_s =
        (Mpl_string32.to_string k_s)
      (* set_k_s unsupported for now (type custom_type) *)

      method e =
        (e)
      (* set_e unsupported for now (type custom_type) *)

      method f =
        (f)
      (* set_f unsupported for now (type custom_type) *)

      method k =
        (k)
      (* set_k unsupported for now (type custom_type) *)


      method prettyprint =
        let out = prerr_endline in
        out "[ Kex_hash.kex_hash ]";
        out ("  v_c = " ^ (Mpl_string32.prettyprint self#v_c));
        out ("  v_s = " ^ (Mpl_string32.prettyprint self#v_s));
        out ("  i_c = " ^ (Mpl_string32.prettyprint self#i_c));
        out ("  i_s = " ^ (Mpl_string32.prettyprint self#i_s));
        out ("  k_s = " ^ (Mpl_string32.prettyprint self#k_s));
        out ("  e = " ^ (Mpl_mpint.prettyprint self#e));
        out ("  f = " ^ (Mpl_mpint.prettyprint self#f));
        out ("  k = " ^ (Mpl_mpint.prettyprint self#k));
        ()
    end

  let t
    ~v_c
    ~v_s
    ~i_c
    ~i_s
    ~k_s
    ~e
    ~f
    ~k
    env =
      let v_c = (Mpl_string32.of_string v_c) in (* custom *)
      let v_s = (Mpl_string32.of_string v_s) in (* custom *)
      let i_c = (Mpl_string32.of_string i_c) in (* custom *)
      let i_s = (Mpl_string32.of_string i_s) in (* custom *)
      let k_s = (Mpl_string32.of_string k_s) in (* custom *)
      let e = (e) in (* custom *)
      let f = (f) in (* custom *)
      let k = (k) in (* custom *)
      let v_c = Mpl_string32.marshal env v_c in
      let v_s = Mpl_string32.marshal env v_s in
      let i_c = Mpl_string32.marshal env i_c in
      let i_s = Mpl_string32.marshal env i_s in
      let k_s = Mpl_string32.marshal env k_s in
      let e = Mpl_mpint.marshal env e in
      let f = Mpl_mpint.marshal env f in
      let k = Mpl_mpint.marshal env k in
      new o
      ~v_c:v_c
      ~v_s:v_s
      ~i_c:i_c
      ~i_s:i_s
      ~k_s:k_s
      ~e:e
      ~f:f
      ~k:k
      env

  let m (x:(env->o)) env = x env
  let sizeof (x:o) = x#sizeof
  let prettyprint (x:o) = x#prettyprint
  let env (x:o) = x#env
  let recv_statecall = `Receive_Kex_hash

  let unmarshal 
    (env:env) : o =
    let v_c = Mpl_string32.unmarshal env in (* custom *)
    let v_s = Mpl_string32.unmarshal env in (* custom *)
    let i_c = Mpl_string32.unmarshal env in (* custom *)
    let i_s = Mpl_string32.unmarshal env in (* custom *)
    let k_s = Mpl_string32.unmarshal env in (* custom *)
    let e = Mpl_mpint.unmarshal env in (* custom *)
    let f = Mpl_mpint.unmarshal env in (* custom *)
    let k = Mpl_mpint.unmarshal env in (* custom *)
    new o env
    ~v_c:v_c
    ~v_s:v_s
    ~i_c:i_c
    ~i_s:i_s
    ~k_s:k_s
    ~e:e
    ~f:f
    ~k:k
end

